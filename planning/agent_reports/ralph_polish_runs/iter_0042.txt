OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/yani/Noema/backend
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: none
reasoning summaries: auto
session id: 019c3ca7-03ec-7fd0-ba39-ed7ca4e5f8a4
--------
user
You are an autonomous coding agent polishing the Noema repository.

Hard rules:
- DO NOT run git commit, git reset, git clean, or anything that modifies git history.
- I will run git commits outside of you.
- Keep changes small: max 3 files per iteration.
- No cosmetic-only edits.
- No new dependencies unless absolutely necessary.

Goal: continuously improve production quality.

Iteration:
1) Run: cd backend && go test ./...
2) If failing: fix the smallest root cause (max 3 files), rerun tests until passing.
3) If passing: make ONE meaningful improvement (max 3 files), then rerun tests until passing.

Pick the highest-value improvement:
A) Reliability/correctness: validation, error handling, run persistence, verify robustness
B) Tests: add/strengthen tests for the change you made
C) Gemini integration correctness (only when eval_output missing) with deterministic fallback
D) Maintainability: reduce duplication with tiny refactors
E) UX: wizard/results/verify clarity (small, safe changes)
F) Docs: README/DEPLOYMENT polish
G) Performance: safe wins only

Finish with:
- What you changed (short)
- Tests run (must include go test ./...)
mcp startup: no servers

thinking
**Running Go tests**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend succeeded in 96ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
ok  	noema/internal/evaluate	(cached)
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/httputil	(cached)
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	(cached)
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)

thinking
**Planning targeted improvement**

Tests are passing, so I'll inspect the repo with a focus on reliability to identify a high-impact change limited to three files.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg --files' in /Users/yani/Noema/backend succeeded in 52ms:
go.sum
internal/session/session_test.go
internal/session/session.go
internal/evaluate/prompt.go
internal/evaluate/parse.go
internal/evaluate/output.go
internal/evaluate/handler_test.go
internal/evaluate/schema.go
internal/evaluate/dataset.go
internal/evaluate/storage.go
internal/evaluate/images.go
internal/evaluate/handler_integration_test.go
internal/evaluate/cache.go
internal/evaluate/commitment.go
internal/evaluate/policy.go
internal/evaluate/spec.go
internal/evaluate/gemini_eval.go
internal/evaluate/handler.go
internal/web/auth.go
internal/web/upload.go

thinking
**Investigating HTTP utility for error handling**

Starting to inspect the HTTP utility, focusing on body or related files, to assess current reliability and error handling for potential improvements.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/httputil/body.go" in /Users/yani/Noema/backend succeeded in 52ms:
package httputil

import (
	"errors"
	"net/http"
	"strings"
)

// IsBodyTooLarge reports whether the error indicates the request body exceeded MaxBytesReader.
func IsBodyTooLarge(err error) bool {
	if err == nil {
		return false
	}
	var maxBytesErr *http.MaxBytesError
	if errors.As(err, &maxBytesErr) {
		return true
	}
	msg := err.Error()
	return strings.Contains(msg, "request body too large") ||
		strings.Contains(msg, "multipart: message too large")

thinking
**Inspecting error handling in upload**

I'm checking error detection for "http: request body too large" and evaluating parse error handling to improve reliability. Next, I'll review how upload handles these errors.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/web/upload.go" in /Users/yani/Noema/backend succeeded in 51ms:
package web

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"noema/internal/config"
	"noema/internal/httputil"

	"github.com/gin-gonic/gin"
)

// UploadData is passed to the upload template.
type UploadData struct {
	Error    string

thinking
**Considering file validation and parse evaluation**
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/parse.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"strings"

	"noema/internal/config"
)

func parseSpec(form *multipart.Form) (Spec, error) {
	specStrs := form.Value["spec"]
	if len(specStrs) == 0 || specStrs[0] == "" {
		return Spec{}, fmt.Errorf("missing field: spec")
	}
	if len(specStrs) > 1 {
		return Spec{}, fmt.Errorf("only one spec value allowed")
	}

thinking
**Checking image duplicate validation**

I'm considering adding case-sensitive duplicate checks for images, likely within the verify handler, and will inspect its current implementation.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/verify/handler.go" in /Users/yani/Noema/backend succeeded in 52ms:
package verify

import (
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"noema/internal/config"
	"noema/internal/httputil"
	"noema/internal/zk"

	"github.com/gin-gonic/gin"
)

// VerifyRequest is the JSON body for POST /api/verify.
type VerifyRequest struct {
	RunID           string `json:"run_id"`
	ProofB64        string `json:"proof_b64"`
	PublicInputsB64 string `json:"public_inputs_b64"`

thinking
**Inspecting legacy evaluation storage**

I'm checking the internal evaluate storage implementation to see if improving legacy verification is needed or if the current approach is sufficient.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,240p' internal/evaluate/storage.go" in /Users/yani/Noema/backend succeeded in 51ms:
package evaluate

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"mime/multipart"
	"os"
	"path/filepath"
	"strconv"
	"sync/atomic"
	"time"
)

var runIDCounter uint64

func genRunID() string {
	n, err := rand.Int(rand.Reader, big.NewInt(1e9))

thinking
**Considering improved error cleanup**

I'm thinking about enhancing error handling in saveRunFiles to remove partial files if an error occurs, though it's a minor issue; also considering if similar improvements apply to evaluate/handler.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,240p' internal/evaluate/handler.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"encoding/json"
	"fmt"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"noema/internal/config"
	"noema/internal/httputil"
	"noema/internal/zk"

	"github.com/gin-gonic/gin"
)

thinking
**Reviewing reliability and validation improvements**

I'm considering adding checks for corrupted run index handling, verifying dataset file size, ensuring safe filename sanitization, improving error returns on partial save failures, and testing request body size limits. Next, I'll focus on adding a meaningful test for handling oversized request bodies.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/httputil/body_test.go" in /Users/yani/Noema/backend succeeded in 52ms:
package httputil

import (
	"errors"
	"net/http"
	"testing"
)

func TestIsBodyTooLarge(t *testing.T) {
	tests := []struct {
		name string
		err  error
		want bool
	}{
		{name: "nil", err: nil, want: false},
		{name: "max bytes error", err: &http.MaxBytesError{Limit: 1}, want: true},
		{name: "http too large string", err: errors.New("http: request body too large"), want: true},
		{name: "multipart too large string", err: errors.New("multipart: message too large"), want: true},
		{name: "other error", err: errors.New("boom"), want: false},
	}


thinking
**Reviewing upload file handling and validations**

Considering additional error detection for request size, checking path traversal seems safe with generated names, and thinking about enforcing case-insensitive uniqueness on uploaded image filenames to avoid OS-related ambiguity. Also weighing UX improvements by rejecting multiple uploaded files instead of silently using only the first.
thinking
**Planning stricter spec and dataset validations**

Planning to add validation for non-empty dataset files during upload and considering trimming or enforcing non-empty spec evaluation names. Also noting potential improvements in error detail for invalid JSON parsing without exposing specifics.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,240p' internal/evaluate/handler_test.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"bytes"
	"encoding/json"
	"fmt"
	"mime/multipart"
	"net/textproto"
	"os"
	"path/filepath"
	"sort"
	"testing"
	"time"
)

type formFile struct {
	field       string
	filename    string
	contentType string
	content     []byte

thinking
**Planning explicit empty dataset validation**

Considering adding a size check in dataset parsing to give clearer error for empty dataset files, supplemented by tests within just two files; next, inspecting dataset reading code to confirm behavior and refine validation.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/evaluate/dataset.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"strings"
)

type Dataset struct {
	Items []DatasetItem `json:"items"`
}

type DatasetItem struct {
	ID       string         `json:"id"`
	Text     string         `json:"text"`
	Metadata map[string]any `json:"metadata,omitempty"`
	ImageRef string         `json:"image_ref,omitempty"`

thinking
**Reviewing dataset and upload validation**

The dataset reading handles emptiness well, so extra parseUploads checks aren't needed; image validation currently allows empty references, and duplicates aren't checked case-insensitively. Error handling and atomic writes appear reliable, with possible test additions for index archiving under consideration. Next, I'll explore evaluation output parsing for further insights.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,240p' internal/evaluate/output.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
)

type EvalConstraintResult struct {
	ID        string `json:"id"`
	Severity  int    `json:"severity"`
	Rationale string `json:"rationale"`
}

type EvalOutput struct {
	SchemaVersion int                    `json:"schema_version"`
	Constraints   []EvalConstraintResult `json:"constraints"`
	MaxSeverity   int                    `json:"max_severity"`
	Confidence    *float64               `json:"confidence,omitempty"`

thinking
**Noting generic parse error message**

The parseEvalOutput error message is generic and could be improved, possibly by enhancing error handling in evaluate/images.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/evaluate/images.go" in /Users/yani/Noema/backend succeeded in 51ms:
package evaluate

import (
	"fmt"
	"io"
	"mime"
	"mime/multipart"
	"path/filepath"
	"strings"
)

type ImageInfo struct {
	Filename string
	MIMEType string
	Data     []byte
}

func readImages(files []*multipart.FileHeader) ([]ImageInfo, error) {
	out := make([]ImageInfo, 0, len(files))
	for _, fh := range files {

thinking
**Reviewing max bytes and validation**

I confirmed max bytes are handled in parseUploads and httputil.IsBodyTooLarge properly checks errors. Next, Iâ€™ll inspect internal/config/limits.go for config improvements and reconsider verifying run_id for allowed characters.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/config/limits.go" in /Users/yani/Noema/backend succeeded in 52ms:
package config

const (
	MaxDatasetBytes    = 50 * 1024 * 1024 // 50MB
	MaxImageBytes      = 5 * 1024 * 1024  // 5MB
	MaxImages          = 10
	MaxUploadBytes     = 50 * 1024 * 1024 // 50MB
	MaxVerifyBytes     = 5 * 1024 * 1024  // 5MB
	MaxMultipartMemory = 100 << 20        // 100MB for evaluate (dataset + images)
)

thinking
**Reviewing multipart size handling**

I'm examining whether the current dataset file size check is sufficient since multipart headers might omit size details, and noting that FileHeader.Size should be reliably set when parsing forms. I'm also considering whether Gin's default multipart memory limit (likely 32MB) is actually enforced or overridden by config.MaxMultipartMemory, which appears unused and may need integration.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg "MaxMultipartMemory" -n' in /Users/yani/Noema/backend succeeded in 51ms:
internal/config/limits.go:9:	MaxMultipartMemory = 100 << 20        // 100MB for evaluate (dataset + images)
cmd/server/main.go:32:	r.MaxMultipartMemory = config.MaxMultipartMemory

thinking
**Noting potential improvements in error handling**

Considering adding tests for parsing unknown fields and handling corrupted indexes more robustly; also pondering error handling for non-JSON dataset files and inspecting cache-related code next.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,240p' internal/evaluate/cache.go" in /Users/yani/Noema/backend succeeded in 51ms:
package evaluate

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"
)

type CachedGeminiOutput struct {
	Model         string       `json:"model"`
	PromptVersion string       `json:"prompt_version"`
	Output        EvalOutput   `json:"output"`
	RawText       string       `json:"raw_text"`
	Usage         *GeminiUsage `json:"usage,omitempty"`
	CachedAt      string       `json:"cached_at"`
}

thinking
**Considering error handling improvements**

I'm reviewing potential enhancements like ignoring stale cache, limiting file reads, and verifying run_id sanity, but key improvements may lie in adding missing error handling in the web/results area.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,240p' internal/web/results.go" in /Users/yani/Noema/backend succeeded in 52ms:
package web

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// ResultsData is passed to the results template.
type ResultsData struct {
	RunID string
}

// ResultsPage renders GET /app/results/:id.
func ResultsPage(c *gin.Context, tmpl string, runID string) {
	c.HTML(http.StatusOK, tmpl, ResultsData{RunID: runID})
}


thinking
**Considering filename normalization for image uploads**

I'm noticing potential mismatches in filename handling between uploaded images and dataset references, especially when uploaded filenames include paths or Windows-style separators. Normalizing to base filenames could prevent false errors and improve validation consistency. Next, I'll explore enforcing this normalization and adding tests.
thinking
**Reviewing error handling and data persistence**

I'm noting that proof verification properly returns errors and logs updateRunsIndex results when encountering archived indexes. Also, image duplicates checks consider path separators correctly. I'm investigating whether spec and eval data persist alongside datasets and images, planning to check saveJSON usage next.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg "saveJSON" -n internal/evaluate' in /Users/yani/Noema/backend succeeded in 52ms:
internal/evaluate/storage.go:63:func saveJSON(path string, v any) error {
internal/evaluate/storage.go:144:	if err := saveJSON(indexPath, entries); err != nil {
internal/evaluate/cache.go:64:	return saveJSON(path, out)

thinking
**Searching for test run path**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg "runPath" -n internal/evaluate' in /Users/yani/Noema/backend succeeded in 51ms:
internal/evaluate/storage.go:32:func saveRunFiles(runPath string, dataset *multipart.FileHeader, images []*multipart.FileHeader) error {
internal/evaluate/storage.go:33:	if err := saveUpload(dataset, filepath.Join(runPath, "dataset.json")); err != nil {
internal/evaluate/storage.go:41:		dst := filepath.Join(runPath, fmt.Sprintf("image_%d%s", i, ext))
internal/evaluate/handler.go:81:		runPath := filepath.Join(runsDir, runID)
internal/evaluate/handler.go:82:		if err := ensureRunDir(runPath); err != nil {
internal/evaluate/handler.go:89:				_ = os.RemoveAll(runPath)
internal/evaluate/handler.go:93:		if err := saveRunFiles(runPath, datasetFile, imageFiles); err != nil {

thinking
**Assessing spec handling and validations**

I'm noting the spec and eval aren't saved currently, possibly by design, and considering improvements to parseSpec for stricter whitespace checks and erroring on eval name whitespace. I'll also check validateSpec for handling of enabled flags in allowed max severity, verifying if missing or disabled specs affect validation logic, starting by inspecting spec.go.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,240p' internal/evaluate/spec.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

// Spec is the parsed evaluation spec (schema_version 1).
type Spec struct {
	SchemaVersion     int                `json:"schema_version"`
	EvaluationName    string             `json:"evaluation_name"`
	Policy            Policy             `json:"policy"`
	Constraints       []Constraint       `json:"constraints"`
	CustomConstraints []CustomConstraint `json:"custom_constraints"`
}

type Policy struct {
	Reveal RevealPolicy `json:"reveal"`
}

type RevealPolicy struct {
	MaxSeverity bool `json:"max_severity"`
	Commitment  bool `json:"commitment"`
}



thinking
**Considering cautious validation enhancements**

I'm weighing adding validation for custom constraints' title/description and tests for validateSpec but avoiding aggressive behavior changes that might break clients; trimming whitespace or minimal checks seem safer improvements. Adding JSON error details on parse failure may help debugging but risks leaking internals, so it's avoided. Existing strictness around dataset fields and image file counts seems adequate.
thinking
**Reviewing input trimming and cache validation**

I confirmed base64 strings are trimmed before decoding to prevent whitespace errors and noted the cache loader doesn't validate alignment with enabled settings but seems safe due to dataset/spec checks. Next, I'll check how evaluation output parsing handles leading or trailing whitespace.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '240,520p' internal/evaluate/handler.go" in /Users/yani/Noema/backend succeeded in 51ms:
	}
	for id := range enabled {
		out.Constraints = append(out.Constraints, EvalConstraintResult{
			ID:        id,
			Severity:  0,
			Rationale: "stub",
		})
	}
	sort.Slice(out.Constraints, func(i, j int) bool {
		return out.Constraints[i].ID < out.Constraints[j].ID
	})
	return out
}

func jsonBytes(v any) ([]byte, error) {
	return json.Marshal(v)
}

func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
	if form == nil || len(form.Value["eval_output"]) == 0 {


thinking
**Adding strict filename validation for uploads**

I'm adding checks to ensure uploaded image filenames are non-empty, have no leading/trailing whitespace, and contain no path separators to prevent confusion with dataset references. This improves robustness against malformed or suspicious upload names.
thinking
**Planning filename validation import and test additions**

I'm adding the filepath import and planning tests for parseUploads filename checks using the existing buildMultipartForm helper in handler_test.go. Tests will ensure errors occur when image filenames include path separators or whitespace, verifying early validation before dataset JSON parsing.
file update
M /Users/yani/Noema/backend/internal/evaluate/parse.go
@@ -7,2 +7,3 @@
 	"mime/multipart"
+	"path/filepath"
 	"strings"
@@ -90,2 +91,12 @@
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
apply_patch(auto_approved=true) exited 0 in 29ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/evaluate/parse.go
file update:
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}

file update:
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}


thinking
**Updating test file imports and adding new test**
file update
M /Users/yani/Noema/backend/internal/evaluate/handler_test.go
@@ -11,2 +11,3 @@
 	"sort"
+	"strings"
 	"testing"
@@ -99,2 +100,26 @@
 
+func TestParseUploads_RejectsImageFilenameWithPath(t *testing.T) {
+	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
+	form := buildMultipartForm(t, []formFile{
+		{
+			field:       "dataset",
+			filename:    "dataset.json",
+			contentType: "application/json",
+			content:     []byte(dataset),
+		},
+		{
+			field:       "images",
+			filename:    "images/unsafe.png",
+			contentType: "image/png",
+			content:     []byte("fake"),
+		},
+	})
+
+	if _, _, err := parseUploads(form); err == nil {
+		t.Fatalf("expected error for image filename with path separators")
+	} else if !strings.Contains(err.Error(), "path separators") {
+		t.Fatalf("unexpected error: %v", err)
+	}
+}
+
 func TestParseEvalOutputOptional_UsesProvidedOutput(t *testing.T) {
apply_patch(auto_approved=true) exited 0 in 35ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/evaluate/handler_test.go
file update:
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index e1ebdf6eb56136a8a4119c5f742a32178fa46bc2..9f28247903452e22f6d001790aa0a8a517871b32
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -9,6 +9,7 @@
 	"os"
 	"path/filepath"
 	"sort"
+	"strings"
 	"testing"
 	"time"
 )
@@ -97,6 +98,30 @@
 	}
 }
 
+func TestParseUploads_RejectsImageFilenameWithPath(t *testing.T) {
+	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
+	form := buildMultipartForm(t, []formFile{
+		{
+			field:       "dataset",
+			filename:    "dataset.json",
+			contentType: "application/json",
+			content:     []byte(dataset),
+		},
+		{
+			field:       "images",
+			filename:    "images/unsafe.png",
+			contentType: "image/png",
+			content:     []byte("fake"),
+		},
+	})
+
+	if _, _, err := parseUploads(form); err == nil {
+		t.Fatalf("expected error for image filename with path separators")
+	} else if !strings.Contains(err.Error(), "path separators") {
+		t.Fatalf("unexpected error: %v", err)
+	}
+}
+
 func TestParseEvalOutputOptional_UsesProvidedOutput(t *testing.T) {
 	spec := Spec{
 		SchemaVersion: 1,
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}

file update:
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index e1ebdf6eb56136a8a4119c5f742a32178fa46bc2..9f28247903452e22f6d001790aa0a8a517871b32
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -9,6 +9,7 @@
 	"os"
 	"path/filepath"
 	"sort"
+	"strings"
 	"testing"
 	"time"
 )
@@ -97,6 +98,30 @@
 	}
 }
 
+func TestParseUploads_RejectsImageFilenameWithPath(t *testing.T) {
+	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
+	form := buildMultipartForm(t, []formFile{
+		{
+			field:       "dataset",
+			filename:    "dataset.json",
+			contentType: "application/json",
+			content:     []byte(dataset),
+		},
+		{
+			field:       "images",
+			filename:    "images/unsafe.png",
+			contentType: "image/png",
+			content:     []byte("fake"),
+		},
+	})
+
+	if _, _, err := parseUploads(form); err == nil {
+		t.Fatalf("expected error for image filename with path separators")
+	} else if !strings.Contains(err.Error(), "path separators") {
+		t.Fatalf("unexpected error: %v", err)
+	}
+}
+
 func TestParseEvalOutputOptional_UsesProvidedOutput(t *testing.T) {
 	spec := Spec{
 		SchemaVersion: 1,
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}


thinking
**Running full Go test suite**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend exited 1 in 587ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
--- FAIL: TestParseUploads_RejectsImageFilenameWithPath (0.00s)
    handler_test.go:119: expected error for image filename with path separators
FAIL
FAIL	noema/internal/evaluate	0.105s
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/httputil	(cached)
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	(cached)
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)
FAIL
file update:
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index e1ebdf6eb56136a8a4119c5f742a32178fa46bc2..9f28247903452e22f6d001790aa0a8a517871b32
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -9,6 +9,7 @@
 	"os"
 	"path/filepath"
 	"sort"
+	"strings"
 	"testing"
 	"time"
 )
@@ -97,6 +98,30 @@
 	}
 }
 
+func TestParseUploads_RejectsImageFilenameWithPath(t *testing.T) {
+	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
+	form := buildMultipartForm(t, []formFile{
+		{
+			field:       "dataset",
+			filename:    "dataset.json",
+			contentType: "application/json",
+			content:     []byte(dataset),
+		},
+		{
+			field:       "images",
+			filename:    "images/unsafe.png",
+			contentType: "image/png",
+			content:     []byte("fake"),
+		},
+	})
+
+	if _, _, err := parseUploads(form); err == nil {
+		t.Fatalf("expected error for image filename with path separators")
+	} else if !strings.Contains(err.Error(), "path separators") {
+		t.Fatalf("unexpected error: %v", err)
+	}
+}
+
 func TestParseEvalOutputOptional_UsesProvidedOutput(t *testing.T) {
 	spec := Spec{
 		SchemaVersion: 1,
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}



thinking
**Adjusting filename validation test**

The previous test failed because the multipart parser likely normalizes filenames to their base name, stripping paths like "images/unsafe.png" to "unsafe.png," bypassing the intended check. I'll modify the test to use filenames with leading/trailing whitespace, which should be preserved and trigger validation errors as expected.
thinking
**Refining test to check whitespace validation**

I'm updating the test to use a filename with leading/trailing whitespace (" bad.png ") and expecting an error mentioning whitespace; the path sanitization remains in code for safety, but this change ensures the test reliably triggers validation failures.
file update
M /Users/yani/Noema/backend/internal/evaluate/handler_test.go
@@ -100,3 +100,3 @@
 
-func TestParseUploads_RejectsImageFilenameWithPath(t *testing.T) {
+func TestParseUploads_RejectsImageFilenameWhitespace(t *testing.T) {
 	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
@@ -111,3 +111,3 @@
 			field:       "images",
-			filename:    "images/unsafe.png",
+			filename:    " bad.png ",
 			contentType: "image/png",
@@ -118,4 +118,4 @@
 	if _, _, err := parseUploads(form); err == nil {
-		t.Fatalf("expected error for image filename with path separators")
-	} else if !strings.Contains(err.Error(), "path separators") {
+		t.Fatalf("expected error for image filename with whitespace")
+	} else if !strings.Contains(err.Error(), "leading/trailing whitespace") {
 		t.Fatalf("unexpected error: %v", err)
apply_patch(auto_approved=true) exited 0 in 41ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/evaluate/handler_test.go
file update:
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index e1ebdf6eb56136a8a4119c5f742a32178fa46bc2..67e7a3dfdb544e290d4bbb03691a2cd295e32621
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -9,6 +9,7 @@
 	"os"
 	"path/filepath"
 	"sort"
+	"strings"
 	"testing"
 	"time"
 )
@@ -97,6 +98,30 @@
 	}
 }
 
+func TestParseUploads_RejectsImageFilenameWhitespace(t *testing.T) {
+	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
+	form := buildMultipartForm(t, []formFile{
+		{
+			field:       "dataset",
+			filename:    "dataset.json",
+			contentType: "application/json",
+			content:     []byte(dataset),
+		},
+		{
+			field:       "images",
+			filename:    " bad.png ",
+			contentType: "image/png",
+			content:     []byte("fake"),
+		},
+	})
+
+	if _, _, err := parseUploads(form); err == nil {
+		t.Fatalf("expected error for image filename with whitespace")
+	} else if !strings.Contains(err.Error(), "leading/trailing whitespace") {
+		t.Fatalf("unexpected error: %v", err)
+	}
+}
+
 func TestParseEvalOutputOptional_UsesProvidedOutput(t *testing.T) {
 	spec := Spec{
 		SchemaVersion: 1,
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}

file update:
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index e1ebdf6eb56136a8a4119c5f742a32178fa46bc2..67e7a3dfdb544e290d4bbb03691a2cd295e32621
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -9,6 +9,7 @@
 	"os"
 	"path/filepath"
 	"sort"
+	"strings"
 	"testing"
 	"time"
 )
@@ -97,6 +98,30 @@
 	}
 }
 
+func TestParseUploads_RejectsImageFilenameWhitespace(t *testing.T) {
+	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
+	form := buildMultipartForm(t, []formFile{
+		{
+			field:       "dataset",
+			filename:    "dataset.json",
+			contentType: "application/json",
+			content:     []byte(dataset),
+		},
+		{
+			field:       "images",
+			filename:    " bad.png ",
+			contentType: "image/png",
+			content:     []byte("fake"),
+		},
+	})
+
+	if _, _, err := parseUploads(form); err == nil {
+		t.Fatalf("expected error for image filename with whitespace")
+	} else if !strings.Contains(err.Error(), "leading/trailing whitespace") {
+		t.Fatalf("unexpected error: %v", err)
+	}
+}
+
 func TestParseEvalOutputOptional_UsesProvidedOutput(t *testing.T) {
 	spec := Spec{
 		SchemaVersion: 1,
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}


thinking
**Running tests again**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend succeeded in 502ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
ok  	noema/internal/evaluate	0.098s
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/httputil	(cached)
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	(cached)
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)
file update:
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index e1ebdf6eb56136a8a4119c5f742a32178fa46bc2..67e7a3dfdb544e290d4bbb03691a2cd295e32621
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -9,6 +9,7 @@
 	"os"
 	"path/filepath"
 	"sort"
+	"strings"
 	"testing"
 	"time"
 )
@@ -97,6 +98,30 @@
 	}
 }
 
+func TestParseUploads_RejectsImageFilenameWhitespace(t *testing.T) {
+	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
+	form := buildMultipartForm(t, []formFile{
+		{
+			field:       "dataset",
+			filename:    "dataset.json",
+			contentType: "application/json",
+			content:     []byte(dataset),
+		},
+		{
+			field:       "images",
+			filename:    " bad.png ",
+			contentType: "image/png",
+			content:     []byte("fake"),
+		},
+	})
+
+	if _, _, err := parseUploads(form); err == nil {
+		t.Fatalf("expected error for image filename with whitespace")
+	} else if !strings.Contains(err.Error(), "leading/trailing whitespace") {
+		t.Fatalf("unexpected error: %v", err)
+	}
+}
+
 func TestParseEvalOutputOptional_UsesProvidedOutput(t *testing.T) {
 	spec := Spec{
 		SchemaVersion: 1,
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}


thinking
**Summarizing changes and tests**

I'm preparing to summarize the implemented changes with file paths and mention the tests run, including any suggestions only if they arise naturally.
codex
What you changed (short)
1. Added stricter image filename validation in `internal/evaluate/parse.go` to reject empty, whitespace-padded, or path-containing names before dataset validation.
2. Added a regression test for whitespace-padded image filenames in `internal/evaluate/handler_test.go`.

Tests run (must include go test ./...)
1. `go test ./...`

If you want, I can add a follow-up test that explicitly validates the path separator check by constructing a `multipart.FileHeader` directly (the standard multipart parser normalizes filenames).
file update:
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index e1ebdf6eb56136a8a4119c5f742a32178fa46bc2..67e7a3dfdb544e290d4bbb03691a2cd295e32621
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -9,6 +9,7 @@
 	"os"
 	"path/filepath"
 	"sort"
+	"strings"
 	"testing"
 	"time"
 )
@@ -97,6 +98,30 @@
 	}
 }
 
+func TestParseUploads_RejectsImageFilenameWhitespace(t *testing.T) {
+	dataset := `{"items":[{"id":"item-1","text":"hello"}]}`
+	form := buildMultipartForm(t, []formFile{
+		{
+			field:       "dataset",
+			filename:    "dataset.json",
+			contentType: "application/json",
+			content:     []byte(dataset),
+		},
+		{
+			field:       "images",
+			filename:    " bad.png ",
+			contentType: "image/png",
+			content:     []byte("fake"),
+		},
+	})
+
+	if _, _, err := parseUploads(form); err == nil {
+		t.Fatalf("expected error for image filename with whitespace")
+	} else if !strings.Contains(err.Error(), "leading/trailing whitespace") {
+		t.Fatalf("unexpected error: %v", err)
+	}
+}
+
 func TestParseEvalOutputOptional_UsesProvidedOutput(t *testing.T) {
 	spec := Spec{
 		SchemaVersion: 1,
diff --git a/backend/internal/evaluate/parse.go b/backend/internal/evaluate/parse.go
index d844664beee856e4797566f516aea76d3c594542..5da5c766cf6be84d247c765f4384dd55bab9ace1
--- a/backend/internal/evaluate/parse.go
+++ b/backend/internal/evaluate/parse.go
@@ -5,6 +5,7 @@
 	"fmt"
 	"io"
 	"mime/multipart"
+	"path/filepath"
 	"strings"
 
 	"noema/internal/config"
@@ -88,6 +89,16 @@
 	}
 	seenImageNames := make(map[string]struct{}, len(imageFiles))
 	for _, f := range imageFiles {
+		trimmedName := strings.TrimSpace(f.Filename)
+		if trimmedName == "" {
+			return nil, nil, fmt.Errorf("image filename must be non-empty")
+		}
+		if trimmedName != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include leading/trailing whitespace")
+		}
+		if filepath.Base(f.Filename) != f.Filename {
+			return nil, nil, fmt.Errorf("image filename must not include path separators")
+		}
 		if _, exists := seenImageNames[f.Filename]; exists {
 			return nil, nil, fmt.Errorf("image filenames must be unique")
 		}

tokens used
31,066
What you changed (short)
1. Added stricter image filename validation in `internal/evaluate/parse.go` to reject empty, whitespace-padded, or path-containing names before dataset validation.
2. Added a regression test for whitespace-padded image filenames in `internal/evaluate/handler_test.go`.

Tests run (must include go test ./...)
1. `go test ./...`

If you want, I can add a follow-up test that explicitly validates the path separator check by constructing a `multipart.FileHeader` directly (the standard multipart parser normalizes filenames).
