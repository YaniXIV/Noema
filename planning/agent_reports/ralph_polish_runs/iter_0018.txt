OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/yani/Noema/backend
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: none
reasoning summaries: auto
session id: 019c3c8c-8301-79e0-8767-db70028b52eb
--------
user
You are an autonomous coding agent polishing the Noema repository.

Hard rules:
- DO NOT run git commit, git reset, git clean, or anything that modifies git history.
- I will run git commits outside of you.
- Keep changes small: max 3 files per iteration.
- No cosmetic-only edits.
- No new dependencies unless absolutely necessary.

Goal: continuously improve production quality.

Iteration:
1) Run: cd backend && go test ./...
2) If failing: fix the smallest root cause (max 3 files), rerun tests until passing.
3) If passing: make ONE meaningful improvement (max 3 files), then rerun tests until passing.

Pick the highest-value improvement:
A) Reliability/correctness: validation, error handling, run persistence, verify robustness
B) Tests: add/strengthen tests for the change you made
C) Gemini integration correctness (only when eval_output missing) with deterministic fallback
D) Maintainability: reduce duplication with tiny refactors
E) UX: wizard/results/verify clarity (small, safe changes)
F) Docs: README/DEPLOYMENT polish
G) Performance: safe wins only

Finish with:
- What you changed (short)
- Tests run (must include go test ./...)
mcp startup: no servers

thinking
**Running tests to verify changes**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend succeeded in 229ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
ok  	noema/internal/evaluate	(cached)
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	(cached)
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)

thinking
**Scanning for quick improvements**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "TODO|FIXME|panic|log.Fatal"' in /Users/yani/Noema/backend succeeded in 51ms:
cmd/server/main.go:127:		log.Fatal(err)

thinking
**Reviewing error handling and evaluation**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && ls' in /Users/yani/Noema/backend succeeded in 52ms:
cmd
data
go.mod
go.sum
internal
main
server
web
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "error" internal | head' in /Users/yani/Noema/backend succeeded in 52ms:
internal/evaluate/prompt.go:160:func marshalSampledDataset(ds Dataset) ([]byte, error) {
internal/evaluate/parse.go:13:func parseSpec(form *multipart.Form) (Spec, error) {
internal/evaluate/parse.go:30:func validateSpec(spec Spec) error {
internal/evaluate/parse.go:53:func parseUploads(form *multipart.Form) (*multipart.FileHeader, []*multipart.FileHeader, error) {
internal/evaluate/parse.go:85:func validateDatasetJSON(fh *multipart.FileHeader, imageFiles []*multipart.FileHeader) error {
internal/evaluate/output.go:22:func parseEvalOutput(raw string) (EvalOutput, error) {
internal/evaluate/output.go:49:func validateEvalOutput(out EvalOutput, enabled map[string]ConstraintRule) error {
internal/evaluate/handler_test.go:67:		t.Fatalf("enabledConstraints error: %v", err)
internal/evaluate/handler_test.go:73:		t.Fatalf("parseEvalOutputOptional error: %v", err)
internal/evaluate/handler_test.go:110:		t.Fatalf("enabledConstraints error: %v", err)

thinking
**Reviewing dataset validation function**
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/parse.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"strings"

	"noema/internal/config"
)

func parseSpec(form *multipart.Form) (Spec, error) {
	specStrs := form.Value["spec"]
	if len(specStrs) == 0 || specStrs[0] == "" {
		return Spec{}, fmt.Errorf("missing field: spec")
	}
	var spec Spec
	dec := json.NewDecoder(strings.NewReader(specStrs[0]))
	dec.DisallowUnknownFields()

thinking
**Noting validation and error handling improvements**

Considering enhancing dataset validation to ensure all uploaded images are referenced, and improving parseSpec to surface JSON errors instead of discarding them for better user experience; next step is to check internal evaluation and output code for relevant patterns.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/output.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"bytes"
	"encoding/json"
	"fmt"
)

type EvalConstraintResult struct {
	ID        string `json:"id"`
	Severity  int    `json:"severity"`
	Rationale string `json:"rationale"`
}

type EvalOutput struct {
	SchemaVersion int                    `json:"schema_version"`
	Constraints   []EvalConstraintResult `json:"constraints"`
	MaxSeverity   int                    `json:"max_severity"`
	Confidence    *float64               `json:"confidence,omitempty"`
}

thinking
**Noticing error detail omission**

The parsing error lacks detailed information, possibly by design to avoid leaks. Considering checking internal evaluation handlers next for related error handling.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/evaluate/handler.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"encoding/json"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"noema/internal/config"
	"noema/internal/zk"

	"github.com/gin-gonic/gin"
)

// EvaluateResponse is the JSON response for POST /api/evaluate.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '220,520p' internal/evaluate/handler.go" in /Users/yani/Noema/backend succeeded in 51ms:
	if err != nil {
		return EvalOutput{}, err
	}
	if err := validateEvalOutput(out, enabled); err != nil {
		return EvalOutput{}, err
	}
	return out, nil
}

func stubEvalOutput(enabled map[string]ConstraintRule) EvalOutput {
	out := EvalOutput{
		SchemaVersion: 1,
		Constraints:   make([]EvalConstraintResult, 0, len(enabled)),
		MaxSeverity:   0,
	}
	for id := range enabled {
		out.Constraints = append(out.Constraints, EvalConstraintResult{
			ID:        id,
			Severity:  0,
			Rationale: "stub",

thinking
**Checking eval output handling**

I'm considering if stubbing eval output could avoid leaks but found no clear rationale; next, I'll look for related evaluate or prompt logic.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/evaluate/prompt.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"bytes"
	"encoding/json"
	"fmt"
	"sort"
	"strings"
)

const promptVersion = "noema-eval-v1"

type PromptConstraint struct {
	ID                 string
	Description        string
	SeverityLevels     map[string]string
	AllowedMaxSeverity int
}

var presetConstraints = map[string]PromptConstraint{

thinking
**Noticing generic errors in parsing**

The parseEvalOutput function returns generic errors, so I'll check internal/session details or verification steps next to improve reliability.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "TODO|FIXME" internal' in /Users/yani/Noema/backend exited 1 in 51ms:


thinking
**Reviewing validation and error handling**

I'm considering minor improvements in error messages and validation logic, like clarifying JSON decode errors or refining image filename checks, and whether to warn on unused uploaded images; also reviewing run persistence in evaluation flows.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "ensureRunDir|saveRunFiles|readDatasetFile" -n internal/evaluate' in /Users/yani/Noema/backend succeeded in 51ms:
internal/evaluate/parse.go:86:	_, ds, err := readDatasetFile(fh)
internal/evaluate/dataset.go:22:func readDatasetFile(fh *multipart.FileHeader) ([]byte, Dataset, error) {
internal/evaluate/storage.go:28:func ensureRunDir(path string) error {
internal/evaluate/storage.go:32:func saveRunFiles(runPath string, dataset *multipart.FileHeader, images []*multipart.FileHeader) error {
internal/evaluate/gemini_eval.go:35:	rawDataset, ds, err := readDatasetFile(datasetFile)
internal/evaluate/handler.go:72:		if err := ensureRunDir(runPath); err != nil {
internal/evaluate/handler.go:83:		if err := saveRunFiles(runPath, datasetFile, imageFiles); err != nil {
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/storage.go" in /Users/yani/Noema/backend succeeded in 51ms:
package evaluate

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"mime/multipart"
	"os"
	"path/filepath"
	"strconv"
	"sync/atomic"
	"time"
)

var runIDCounter uint64

func genRunID() string {
	n, err := rand.Int(rand.Reader, big.NewInt(1e9))

thinking
**Reviewing dataset file handling**

I'm considering switching saveUpload to use os.Create for automatic truncation and will check readDatasetFile to add size limits for improved safety.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/dataset.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
)

type Dataset struct {
	Items []DatasetItem `json:"items"`
}

type DatasetItem struct {
	ID       string         `json:"id"`
	Text     string         `json:"text"`
	Metadata map[string]any `json:"metadata,omitempty"`
	ImageRef string         `json:"image_ref,omitempty"`
}

thinking
**Reviewing dataset parsing constraints**

I confirmed that large files are controlled by a max size check before reading, and that unknown fields are disallowed only at the dataset/item top level, allowing flexible metadata maps inside items. Next, I'll examine the gemini evaluation integration for potential improvements.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,260p' internal/evaluate/gemini_eval.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"context"
	"log"
	"mime/multipart"
	"time"

	"noema/internal/config"
	"noema/internal/gemini"
)

const geminiEvalTimeout = 45 * time.Second

func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
		raw := form.Value["eval_output"][0]
		out, err := parseEvalOutput(raw)
		if err != nil {
			return EvalOutput{}, err

thinking
**Considering error handling and caching**

I'm confirming that if an invalid eval_output is provided, the system should return a 400 error, and planning to check for caching logic in the Gemini cache next.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,240p' internal/evaluate/cache.go" in /Users/yani/Noema/backend succeeded in 51ms:
package evaluate

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"time"
)

type CachedGeminiOutput struct {
	Model         string       `json:"model"`
	PromptVersion string       `json:"prompt_version"`
	Output        EvalOutput   `json:"output"`
	RawText       string       `json:"raw_text"`
	Usage         *GeminiUsage `json:"usage,omitempty"`
	CachedAt      string       `json:"cached_at"`
}

thinking
**Noting prompt version check in cache load**

The cache loading should verify the prompt version to avoid stale outputs, as the prompt version is part of the cache key; I'll check internal verification to confirm this.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/verify/handler.go" in /Users/yani/Noema/backend succeeded in 51ms:
package verify

import (
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"noema/internal/zk"

	"github.com/gin-gonic/gin"
)

// VerifyRequest is the JSON body for POST /api/verify.
type VerifyRequest struct {
	RunID           string `json:"run_id"`
	ProofB64        string `json:"proof_b64"`
	PublicInputsB64 string `json:"public_inputs_b64"`
}


thinking
**Considering handler size limits**
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/session/session.go" in /Users/yani/Noema/backend succeeded in 51ms:
package session

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"strings"
)

const CookieName = "noema_judge"

// Sign produces a signed cookie value for the given payload (e.g. judge key).
// Format: base64(payload) + "." + hex(HMAC-SHA256(secret, payload)).
func Sign(secret, payload string) string {
	mac := hmac.New(sha256.New, []byte(secret))
	mac.Write([]byte(payload))
	sig := hex.EncodeToString(mac.Sum(nil))
	encoded := base64.StdEncoding.EncodeToString([]byte(payload))

thinking
**Considering payload validation in session verification**
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/auth/auth.go" in /Users/yani/Noema/backend exited 1 in 52ms:
sed: internal/auth/auth.go: No such file or directory

thinking
**Scanning internal auth code**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && ls internal/auth' in /Users/yani/Noema/backend succeeded in 52ms:
middleware.go
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/auth/middleware.go" in /Users/yani/Noema/backend succeeded in 52ms:
package auth

import (
	"net/http"
	"net/url"
	"strings"

	"noema/internal/config"
	"noema/internal/session"

	"github.com/gin-gonic/gin"
)

// JudgeKey checks the request for a valid judge key (header or query).
// Use for API routes only. Expects X-Judge-Key header or judge_key query param to match JUDGE_KEY in .env.
func JudgeKey() gin.HandlerFunc {
	return func(c *gin.Context) {
		expect := config.JudgeKey()
		if expect == "" {
			c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{"error": "server not configured"})

thinking
**Improving security with constant-time compare**

I identified judge key and cookie payload comparisons could use constant-time string compare for better security and reliability, planning to update these in the auth middleware with subtle.ConstantTimeCompare in Go.
file update
M /Users/yani/Noema/backend/internal/auth/middleware.go
@@ -3,2 +3,3 @@
 import (
+	"crypto/subtle"
 	"net/http"
@@ -26,3 +27,3 @@
 		}
-		if got != expect {
+		if !constantTimeEqual(got, expect) {
 			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid judge key"})
@@ -50,3 +51,3 @@
 		payload, ok := session.Verify(config.CookieSecret(), cookie)
-		if !ok || payload != expect {
+		if !ok || !constantTimeEqual(payload, expect) {
 			abortCookieAuth(c, "Invalid session")
@@ -66 +67,5 @@
 }
+
+func constantTimeEqual(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}
apply_patch(auto_approved=true) exited 0 in 32ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/auth/middleware.go
file update:
diff --git a/backend/internal/auth/middleware.go b/backend/internal/auth/middleware.go
index 3b107a21cad7446198904204cc2c1bc27e13e7d3..f10ecf6a0bc79586a9a46ee4703dc0b00a504e13
--- a/backend/internal/auth/middleware.go
+++ b/backend/internal/auth/middleware.go
@@ -1,6 +1,7 @@
 package auth
 
 import (
+	"crypto/subtle"
 	"net/http"
 	"net/url"
 	"strings"
@@ -24,7 +25,7 @@
 		if got == "" {
 			got = c.Query("judge_key")
 		}
-		if got != expect {
+		if !constantTimeEqual(got, expect) {
 			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid judge key"})
 			return
 		}
@@ -48,7 +49,7 @@
 			return
 		}
 		payload, ok := session.Verify(config.CookieSecret(), cookie)
-		if !ok || payload != expect {
+		if !ok || !constantTimeEqual(payload, expect) {
 			abortCookieAuth(c, "Invalid session")
 			return
 		}
@@ -64,3 +65,7 @@
 	c.Redirect(http.StatusSeeOther, "/?err="+url.QueryEscape(msg))
 	c.Abort()
 }
+
+func constantTimeEqual(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}

file update:
diff --git a/backend/internal/auth/middleware.go b/backend/internal/auth/middleware.go
index 3b107a21cad7446198904204cc2c1bc27e13e7d3..f10ecf6a0bc79586a9a46ee4703dc0b00a504e13
--- a/backend/internal/auth/middleware.go
+++ b/backend/internal/auth/middleware.go
@@ -1,6 +1,7 @@
 package auth
 
 import (
+	"crypto/subtle"
 	"net/http"
 	"net/url"
 	"strings"
@@ -24,7 +25,7 @@
 		if got == "" {
 			got = c.Query("judge_key")
 		}
-		if got != expect {
+		if !constantTimeEqual(got, expect) {
 			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid judge key"})
 			return
 		}
@@ -48,7 +49,7 @@
 			return
 		}
 		payload, ok := session.Verify(config.CookieSecret(), cookie)
-		if !ok || payload != expect {
+		if !ok || !constantTimeEqual(payload, expect) {
 			abortCookieAuth(c, "Invalid session")
 			return
 		}
@@ -64,3 +65,7 @@
 	c.Redirect(http.StatusSeeOther, "/?err="+url.QueryEscape(msg))
 	c.Abort()
 }
+
+func constantTimeEqual(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}


thinking
**Deciding to run gofmt for import sorting**

Decided to run gofmt with write flag to automatically sort imports and ensure consistent formatting despite current format being acceptable.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && gofmt -w internal/auth/middleware.go' in /Users/yani/Noema/backend succeeded in 52ms:

file update:
diff --git a/backend/internal/auth/middleware.go b/backend/internal/auth/middleware.go
index 3b107a21cad7446198904204cc2c1bc27e13e7d3..f10ecf6a0bc79586a9a46ee4703dc0b00a504e13
--- a/backend/internal/auth/middleware.go
+++ b/backend/internal/auth/middleware.go
@@ -1,6 +1,7 @@
 package auth
 
 import (
+	"crypto/subtle"
 	"net/http"
 	"net/url"
 	"strings"
@@ -24,7 +25,7 @@
 		if got == "" {
 			got = c.Query("judge_key")
 		}
-		if got != expect {
+		if !constantTimeEqual(got, expect) {
 			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid judge key"})
 			return
 		}
@@ -48,7 +49,7 @@
 			return
 		}
 		payload, ok := session.Verify(config.CookieSecret(), cookie)
-		if !ok || payload != expect {
+		if !ok || !constantTimeEqual(payload, expect) {
 			abortCookieAuth(c, "Invalid session")
 			return
 		}
@@ -64,3 +65,7 @@
 	c.Redirect(http.StatusSeeOther, "/?err="+url.QueryEscape(msg))
 	c.Abort()
 }
+
+func constantTimeEqual(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}


thinking
**Running all Go tests**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend succeeded in 223ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
ok  	noema/internal/evaluate	(cached)
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	(cached)
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)
file update:
diff --git a/backend/internal/auth/middleware.go b/backend/internal/auth/middleware.go
index 3b107a21cad7446198904204cc2c1bc27e13e7d3..f10ecf6a0bc79586a9a46ee4703dc0b00a504e13
--- a/backend/internal/auth/middleware.go
+++ b/backend/internal/auth/middleware.go
@@ -1,6 +1,7 @@
 package auth
 
 import (
+	"crypto/subtle"
 	"net/http"
 	"net/url"
 	"strings"
@@ -24,7 +25,7 @@
 		if got == "" {
 			got = c.Query("judge_key")
 		}
-		if got != expect {
+		if !constantTimeEqual(got, expect) {
 			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid judge key"})
 			return
 		}
@@ -48,7 +49,7 @@
 			return
 		}
 		payload, ok := session.Verify(config.CookieSecret(), cookie)
-		if !ok || payload != expect {
+		if !ok || !constantTimeEqual(payload, expect) {
 			abortCookieAuth(c, "Invalid session")
 			return
 		}
@@ -64,3 +65,7 @@
 	c.Redirect(http.StatusSeeOther, "/?err="+url.QueryEscape(msg))
 	c.Abort()
 }
+
+func constantTimeEqual(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}


thinking
**Summarizing final changes and tests**

The implementation is complete with tests run and passing. No web-related content is included.
codex
What you changed (short)
- Switched judge key and session payload comparisons to constant-time checks to reduce timing side-channel risk in `internal/auth/middleware.go`.

Tests run
- `go test ./...`
file update:
diff --git a/backend/internal/auth/middleware.go b/backend/internal/auth/middleware.go
index 3b107a21cad7446198904204cc2c1bc27e13e7d3..f10ecf6a0bc79586a9a46ee4703dc0b00a504e13
--- a/backend/internal/auth/middleware.go
+++ b/backend/internal/auth/middleware.go
@@ -1,6 +1,7 @@
 package auth
 
 import (
+	"crypto/subtle"
 	"net/http"
 	"net/url"
 	"strings"
@@ -24,7 +25,7 @@
 		if got == "" {
 			got = c.Query("judge_key")
 		}
-		if got != expect {
+		if !constantTimeEqual(got, expect) {
 			c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "invalid judge key"})
 			return
 		}
@@ -48,7 +49,7 @@
 			return
 		}
 		payload, ok := session.Verify(config.CookieSecret(), cookie)
-		if !ok || payload != expect {
+		if !ok || !constantTimeEqual(payload, expect) {
 			abortCookieAuth(c, "Invalid session")
 			return
 		}
@@ -64,3 +65,7 @@
 	c.Redirect(http.StatusSeeOther, "/?err="+url.QueryEscape(msg))
 	c.Abort()
 }
+
+func constantTimeEqual(a, b string) bool {
+	return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
+}

tokens used
20,137
What you changed (short)
- Switched judge key and session payload comparisons to constant-time checks to reduce timing side-channel risk in `internal/auth/middleware.go`.

Tests run
- `go test ./...`
