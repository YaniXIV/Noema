OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/yani/Noema/backend
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: none
reasoning summaries: auto
session id: 019c3c97-8806-7741-82ce-55f70b5eba9c
--------
user
You are an autonomous coding agent polishing the Noema repository.

Hard rules:
- DO NOT run git commit, git reset, git clean, or anything that modifies git history.
- I will run git commits outside of you.
- Keep changes small: max 3 files per iteration.
- No cosmetic-only edits.
- No new dependencies unless absolutely necessary.

Goal: continuously improve production quality.

Iteration:
1) Run: cd backend && go test ./...
2) If failing: fix the smallest root cause (max 3 files), rerun tests until passing.
3) If passing: make ONE meaningful improvement (max 3 files), then rerun tests until passing.

Pick the highest-value improvement:
A) Reliability/correctness: validation, error handling, run persistence, verify robustness
B) Tests: add/strengthen tests for the change you made
C) Gemini integration correctness (only when eval_output missing) with deterministic fallback
D) Maintainability: reduce duplication with tiny refactors
E) UX: wizard/results/verify clarity (small, safe changes)
F) Docs: README/DEPLOYMENT polish
G) Performance: safe wins only

Finish with:
- What you changed (short)
- Tests run (must include go test ./...)
mcp startup: no servers

thinking
**Running tests command**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend succeeded in 99ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
ok  	noema/internal/evaluate	(cached)
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	(cached)
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)

thinking
**Inspecting code for improvements**

I'm focusing on error handling and searching for TODO comments to find a meaningful, minimal improvement affecting up to three files.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && rg -n \"TODO|FIXME|HACK|panic\\(\" internal" in /Users/yani/Noema/backend exited 1 in 51ms:


thinking
**Inspecting internal directory for missing eval_output**

I see no test results, so I'm checking the internal/gemini area to verify if the eval_output is missing and causing C code to fail. Next, I'll confirm where eval_output is referenced or omitted.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "eval_output" -S internal' in /Users/yani/Noema/backend succeeded in 52ms:
internal/evaluate/handler_test.go:123:		t.Fatalf("marshal eval_output: %v", err)
internal/evaluate/handler_test.go:126:	form := &multipart.Form{Value: map[string][]string{"eval_output": {string(raw)}}}
internal/evaluate/handler_test.go:160:		t.Fatalf("marshal eval_output: %v", err)
internal/evaluate/handler_test.go:163:	form := &multipart.Form{Value: map[string][]string{"eval_output": {string(raw)}}}
internal/evaluate/handler_test.go:190:		t.Fatalf("marshal eval_output: %v", err)
internal/evaluate/handler_test.go:193:	form := &multipart.Form{Value: map[string][]string{"eval_output": {string(raw) + " trailing"}}}
internal/evaluate/handler_test.go:220:		t.Fatalf("marshal eval_output: %v", err)
internal/evaluate/handler_test.go:223:	form := &multipart.Form{Value: map[string][]string{"eval_output": {string(raw), string(raw)}}}
internal/evaluate/handler_test.go:225:		t.Fatalf("expected error for multiple eval_output values")
internal/evaluate/handler_integration_test.go:244:			t.Fatalf("marshal eval_output: %v", err)
internal/evaluate/handler_integration_test.go:246:		if err := writer.WriteField("eval_output", string(evalRaw)); err != nil {
internal/evaluate/handler_integration_test.go:247:			t.Fatalf("write eval_output field: %v", err)
internal/evaluate/gemini_eval.go:16:	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
internal/evaluate/gemini_eval.go:17:		raw := form.Value["eval_output"][0]
internal/evaluate/handler.go:224:	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
internal/evaluate/handler.go:227:	if len(form.Value["eval_output"]) > 1 {
internal/evaluate/handler.go:228:		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
internal/evaluate/handler.go:230:	raw := form.Value["eval_output"][0]

thinking
**Inspecting form error handling**

I'm checking handler.go to assess how form errors are currently handled and identify potential improvements.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '180,280p' internal/evaluate/handler.go" in /Users/yani/Noema/backend succeeded in 52ms:
	}
	entries, err := os.ReadDir(runsDir)
	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return err
	}

	var runs []runEntry
	for _, entry := range entries {
		if !entry.IsDir() {
			continue
		}
		if !strings.HasPrefix(entry.Name(), "run_") {
			continue
		}
		info, err := entry.Info()
		if err != nil {
			continue

thinking
**Reviewing whitespace handling in evaluation parsing**

I'm checking how parseEvalOutputOptional handles multiple or empty values, focusing on treating whitespace as empty, and considering inspecting gemini_eval.go for related logic.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,120p' internal/evaluate/gemini_eval.go" in /Users/yani/Noema/backend succeeded in 51ms:
package evaluate

import (
	"context"
	"log"
	"mime/multipart"
	"time"

	"noema/internal/config"
	"noema/internal/gemini"
)

const geminiEvalTimeout = 45 * time.Second

func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
		raw := form.Value["eval_output"][0]
		out, err := parseEvalOutput(raw)
		if err != nil {
			return EvalOutput{}, err

thinking
**Considering eval_output parsing refactor**

Noted that resolveEvalOutput duplicates parseEvalOutputOptional logic and lacks trimming whitespace or handling multiple values correctly; planning to refactor for reuse, trim whitespace, and enforce single-value validation for gemini paths to improve correctness.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "parseEvalOutputOptional" -S' in /Users/yani/Noema/backend succeeded in 52ms:
internal/evaluate/handler_test.go:71:	out, err := parseEvalOutputOptional(form, enabled)
internal/evaluate/handler_test.go:73:		t.Fatalf("parseEvalOutputOptional error: %v", err)
internal/evaluate/handler_test.go:127:	out, err := parseEvalOutputOptional(form, enabled)
internal/evaluate/handler_test.go:129:		t.Fatalf("parseEvalOutputOptional error: %v", err)
internal/evaluate/handler_test.go:164:	if _, err := parseEvalOutputOptional(form, enabled); err == nil {
internal/evaluate/handler_test.go:194:	if _, err := parseEvalOutputOptional(form, enabled); err == nil {
internal/evaluate/handler_test.go:224:	if _, err := parseEvalOutputOptional(form, enabled); err == nil {
internal/evaluate/handler.go:223:func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {

thinking
**Verifying utility usage**

I'm checking if the parsing utility is used only in tests or also in handler flows, focusing on its relation to resolveEvalOutput within the gemini path.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,140p' internal/evaluate/handler.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"encoding/json"
	"fmt"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"noema/internal/config"
	"noema/internal/zk"

	"github.com/gin-gonic/gin"
)


thinking
**Planning unified eval output parsing**

I'm planning to create a new helper that parses eval output only when present, handling multiple values and whitespace cleanly. This will let both existing functions share consistent parsing logic without breaking current gemini fallback behavior, requiring edits to evaluate handler and gemini code plus tests.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,260p' internal/evaluate/handler_test.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"bytes"
	"encoding/json"
	"fmt"
	"mime/multipart"
	"net/textproto"
	"os"
	"path/filepath"
	"sort"
	"testing"
	"time"
)

type formFile struct {
	field       string
	filename    string
	contentType string
	content     []byte


thinking
**Refactoring parsing for multiple eval outputs**

Planning to unify validation for multiple eval_output values by adding a helper, adjusting parseEvalOutputOptional to reuse it, and updating resolveEvalOutput to handle multiple values and reject whitespace-only inputs to improve gemini fallback handling.
thinking
**Implementing unified parse helper with whitespace handling**

I'm creating a new parseEvalOutputProvided helper in handler.go to handle multiple eval_output values and treat whitespace-only as not provided, updating parseEvalOutputOptional and resolveEvalOutput to use it. I'll add a test in handler_test.go to confirm whitespace-only input returns the stub, and update gemini_eval.go accordingly.
file update
M /Users/yani/Noema/backend/internal/evaluate/handler.go
@@ -223,10 +223,3 @@
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
@@ -234,4 +227,4 @@
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
@@ -263,2 +256,23 @@
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/evaluate/handler.go
file update:
diff --git a/backend/internal/evaluate/handler.go b/backend/internal/evaluate/handler.go
index 4f4ec64db9c59520ce0dccb60daa693b94c4fbad..597d295ae76228e0d0cabbe860b4e2b0c6031827
--- a/backend/internal/evaluate/handler.go
+++ b/backend/internal/evaluate/handler.go
@@ -221,19 +221,12 @@
 }
 
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
 		return EvalOutput{}, err
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
 	return out, nil
 }
@@ -261,6 +254,27 @@
 	return json.Marshal(v)
 }
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
 	if err == nil {
 		return false

file update:
diff --git a/backend/internal/evaluate/handler.go b/backend/internal/evaluate/handler.go
index 4f4ec64db9c59520ce0dccb60daa693b94c4fbad..597d295ae76228e0d0cabbe860b4e2b0c6031827
--- a/backend/internal/evaluate/handler.go
+++ b/backend/internal/evaluate/handler.go
@@ -221,19 +221,12 @@
 }
 
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
 		return EvalOutput{}, err
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
 	return out, nil
 }
@@ -261,6 +254,27 @@
 	return json.Marshal(v)
 }
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
 	if err == nil {
 		return false


thinking
**Updating evaluation logic to use helper**

I'm confirming the strings import is already in place for parsing output and planning to update the evaluation logic in gemini_eval.go to utilize the existing helper.
file update
M /Users/yani/Noema/backend/internal/evaluate/gemini_eval.go
@@ -15,11 +15,5 @@
 func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
-	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
-		raw := form.Value["eval_output"][0]
-		out, err := parseEvalOutput(raw)
-		if err != nil {
-			return EvalOutput{}, err
-		}
-		if err := validateEvalOutput(out, enabled); err != nil {
-			return EvalOutput{}, err
-		}
+	if out, provided, err := parseEvalOutputProvided(form, enabled); err != nil {
+		return EvalOutput{}, err
+	} else if provided {
 		return out, nil
apply_patch(auto_approved=true) exited 0 in 34ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/evaluate/gemini_eval.go
file update:
diff --git a/backend/internal/evaluate/gemini_eval.go b/backend/internal/evaluate/gemini_eval.go
index b440de2eef71bfd21bf7b291ae3a2924998ad61c..f0d96de23750e2fe965b8099573e084b3eba9356
--- a/backend/internal/evaluate/gemini_eval.go
+++ b/backend/internal/evaluate/gemini_eval.go
@@ -13,15 +13,9 @@
 const geminiEvalTimeout = 45 * time.Second
 
 func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
-	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
-		raw := form.Value["eval_output"][0]
-		out, err := parseEvalOutput(raw)
-		if err != nil {
-			return EvalOutput{}, err
-		}
-		if err := validateEvalOutput(out, enabled); err != nil {
-			return EvalOutput{}, err
-		}
+	if out, provided, err := parseEvalOutputProvided(form, enabled); err != nil {
+		return EvalOutput{}, err
+	} else if provided {
 		return out, nil
 	}
 	return evalWithGemini(ctx, enabled, runsDir, spec, datasetFile, imageFiles), nil
diff --git a/backend/internal/evaluate/handler.go b/backend/internal/evaluate/handler.go
index 4f4ec64db9c59520ce0dccb60daa693b94c4fbad..597d295ae76228e0d0cabbe860b4e2b0c6031827
--- a/backend/internal/evaluate/handler.go
+++ b/backend/internal/evaluate/handler.go
@@ -221,19 +221,12 @@
 }
 
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
 		return EvalOutput{}, err
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
 	return out, nil
 }
@@ -261,6 +254,27 @@
 	return json.Marshal(v)
 }
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
 	if err == nil {
 		return false

file update:
diff --git a/backend/internal/evaluate/gemini_eval.go b/backend/internal/evaluate/gemini_eval.go
index b440de2eef71bfd21bf7b291ae3a2924998ad61c..f0d96de23750e2fe965b8099573e084b3eba9356
--- a/backend/internal/evaluate/gemini_eval.go
+++ b/backend/internal/evaluate/gemini_eval.go
@@ -13,15 +13,9 @@
 const geminiEvalTimeout = 45 * time.Second
 
 func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
-	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
-		raw := form.Value["eval_output"][0]
-		out, err := parseEvalOutput(raw)
-		if err != nil {
-			return EvalOutput{}, err
-		}
-		if err := validateEvalOutput(out, enabled); err != nil {
-			return EvalOutput{}, err
-		}
+	if out, provided, err := parseEvalOutputProvided(form, enabled); err != nil {
+		return EvalOutput{}, err
+	} else if provided {
 		return out, nil
 	}
 	return evalWithGemini(ctx, enabled, runsDir, spec, datasetFile, imageFiles), nil
diff --git a/backend/internal/evaluate/handler.go b/backend/internal/evaluate/handler.go
index 4f4ec64db9c59520ce0dccb60daa693b94c4fbad..597d295ae76228e0d0cabbe860b4e2b0c6031827
--- a/backend/internal/evaluate/handler.go
+++ b/backend/internal/evaluate/handler.go
@@ -221,19 +221,12 @@
 }
 
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
 		return EvalOutput{}, err
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
 	return out, nil
 }
@@ -261,6 +254,27 @@
 	return json.Marshal(v)
 }
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
 	if err == nil {
 		return false


thinking
**Adding test in handler_test.go**
file update
M /Users/yani/Noema/backend/internal/evaluate/handler_test.go
@@ -228,2 +228,28 @@
 
+func TestParseEvalOutputOptional_IgnoresWhitespace(t *testing.T) {
+	spec := Spec{
+		SchemaVersion: 1,
+		Constraints: []Constraint{
+			{ID: "pii_exposure_risk", Enabled: true, AllowedMaxSeverity: 1},
+			{ID: "harm_enabling_content_risk", Enabled: true, AllowedMaxSeverity: 2},
+		},
+	}
+	enabled, err := enabledConstraints(spec)
+	if err != nil {
+		t.Fatalf("enabledConstraints error: %v", err)
+	}
+
+	form := &multipart.Form{Value: map[string][]string{"eval_output": {" \n\t "}}}
+	out, err := parseEvalOutputOptional(form, enabled)
+	if err != nil {
+		t.Fatalf("parseEvalOutputOptional error: %v", err)
+	}
+	if len(out.Constraints) != len(enabled) {
+		t.Fatalf("expected %d constraints, got %d", len(enabled), len(out.Constraints))
+	}
+	if out.MaxSeverity != 0 {
+		t.Fatalf("expected max_severity 0, got %d", out.MaxSeverity)
+	}
+}
+
 func TestComputePolicyResult(t *testing.T) {
apply_patch(auto_approved=true) exited 0 in 38ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/evaluate/handler_test.go
file update:
diff --git a/backend/internal/evaluate/gemini_eval.go b/backend/internal/evaluate/gemini_eval.go
index b440de2eef71bfd21bf7b291ae3a2924998ad61c..f0d96de23750e2fe965b8099573e084b3eba9356
--- a/backend/internal/evaluate/gemini_eval.go
+++ b/backend/internal/evaluate/gemini_eval.go
@@ -13,15 +13,9 @@
 const geminiEvalTimeout = 45 * time.Second
 
 func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
-	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
-		raw := form.Value["eval_output"][0]
-		out, err := parseEvalOutput(raw)
-		if err != nil {
-			return EvalOutput{}, err
-		}
-		if err := validateEvalOutput(out, enabled); err != nil {
-			return EvalOutput{}, err
-		}
+	if out, provided, err := parseEvalOutputProvided(form, enabled); err != nil {
+		return EvalOutput{}, err
+	} else if provided {
 		return out, nil
 	}
 	return evalWithGemini(ctx, enabled, runsDir, spec, datasetFile, imageFiles), nil
diff --git a/backend/internal/evaluate/handler.go b/backend/internal/evaluate/handler.go
index 4f4ec64db9c59520ce0dccb60daa693b94c4fbad..597d295ae76228e0d0cabbe860b4e2b0c6031827
--- a/backend/internal/evaluate/handler.go
+++ b/backend/internal/evaluate/handler.go
@@ -221,19 +221,12 @@
 }
 
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
 		return EvalOutput{}, err
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
 	return out, nil
 }
@@ -261,6 +254,27 @@
 	return json.Marshal(v)
 }
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
 	if err == nil {
 		return false
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index 74c11047c23b20e18c977522b72a884927f6ec2c..54f830c7858f496279c6f604af18d16d2a16ac05
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -226,6 +226,32 @@
 	}
 }
 
+func TestParseEvalOutputOptional_IgnoresWhitespace(t *testing.T) {
+	spec := Spec{
+		SchemaVersion: 1,
+		Constraints: []Constraint{
+			{ID: "pii_exposure_risk", Enabled: true, AllowedMaxSeverity: 1},
+			{ID: "harm_enabling_content_risk", Enabled: true, AllowedMaxSeverity: 2},
+		},
+	}
+	enabled, err := enabledConstraints(spec)
+	if err != nil {
+		t.Fatalf("enabledConstraints error: %v", err)
+	}
+
+	form := &multipart.Form{Value: map[string][]string{"eval_output": {" \n\t "}}}
+	out, err := parseEvalOutputOptional(form, enabled)
+	if err != nil {
+		t.Fatalf("parseEvalOutputOptional error: %v", err)
+	}
+	if len(out.Constraints) != len(enabled) {
+		t.Fatalf("expected %d constraints, got %d", len(enabled), len(out.Constraints))
+	}
+	if out.MaxSeverity != 0 {
+		t.Fatalf("expected max_severity 0, got %d", out.MaxSeverity)
+	}
+}
+
 func TestComputePolicyResult(t *testing.T) {
 	enabled := map[string]ConstraintRule{
 		"pii":    {ID: "pii", AllowedMaxSeverity: 1},

file update:
diff --git a/backend/internal/evaluate/gemini_eval.go b/backend/internal/evaluate/gemini_eval.go
index b440de2eef71bfd21bf7b291ae3a2924998ad61c..f0d96de23750e2fe965b8099573e084b3eba9356
--- a/backend/internal/evaluate/gemini_eval.go
+++ b/backend/internal/evaluate/gemini_eval.go
@@ -13,15 +13,9 @@
 const geminiEvalTimeout = 45 * time.Second
 
 func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
-	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
-		raw := form.Value["eval_output"][0]
-		out, err := parseEvalOutput(raw)
-		if err != nil {
-			return EvalOutput{}, err
-		}
-		if err := validateEvalOutput(out, enabled); err != nil {
-			return EvalOutput{}, err
-		}
+	if out, provided, err := parseEvalOutputProvided(form, enabled); err != nil {
+		return EvalOutput{}, err
+	} else if provided {
 		return out, nil
 	}
 	return evalWithGemini(ctx, enabled, runsDir, spec, datasetFile, imageFiles), nil
diff --git a/backend/internal/evaluate/handler.go b/backend/internal/evaluate/handler.go
index 4f4ec64db9c59520ce0dccb60daa693b94c4fbad..597d295ae76228e0d0cabbe860b4e2b0c6031827
--- a/backend/internal/evaluate/handler.go
+++ b/backend/internal/evaluate/handler.go
@@ -221,19 +221,12 @@
 }
 
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
 		return EvalOutput{}, err
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
 	return out, nil
 }
@@ -261,6 +254,27 @@
 	return json.Marshal(v)
 }
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
 	if err == nil {
 		return false
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index 74c11047c23b20e18c977522b72a884927f6ec2c..54f830c7858f496279c6f604af18d16d2a16ac05
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -226,6 +226,32 @@
 	}
 }
 
+func TestParseEvalOutputOptional_IgnoresWhitespace(t *testing.T) {
+	spec := Spec{
+		SchemaVersion: 1,
+		Constraints: []Constraint{
+			{ID: "pii_exposure_risk", Enabled: true, AllowedMaxSeverity: 1},
+			{ID: "harm_enabling_content_risk", Enabled: true, AllowedMaxSeverity: 2},
+		},
+	}
+	enabled, err := enabledConstraints(spec)
+	if err != nil {
+		t.Fatalf("enabledConstraints error: %v", err)
+	}
+
+	form := &multipart.Form{Value: map[string][]string{"eval_output": {" \n\t "}}}
+	out, err := parseEvalOutputOptional(form, enabled)
+	if err != nil {
+		t.Fatalf("parseEvalOutputOptional error: %v", err)
+	}
+	if len(out.Constraints) != len(enabled) {
+		t.Fatalf("expected %d constraints, got %d", len(enabled), len(out.Constraints))
+	}
+	if out.MaxSeverity != 0 {
+		t.Fatalf("expected max_severity 0, got %d", out.MaxSeverity)
+	}
+}
+
 func TestComputePolicyResult(t *testing.T) {
 	enabled := map[string]ConstraintRule{
 		"pii":    {ID: "pii", AllowedMaxSeverity: 1},


thinking
**Running full Go test suite**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend succeeded in 523ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
ok  	noema/internal/evaluate	0.077s
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	(cached)
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)
file update:
diff --git a/backend/internal/evaluate/gemini_eval.go b/backend/internal/evaluate/gemini_eval.go
index b440de2eef71bfd21bf7b291ae3a2924998ad61c..f0d96de23750e2fe965b8099573e084b3eba9356
--- a/backend/internal/evaluate/gemini_eval.go
+++ b/backend/internal/evaluate/gemini_eval.go
@@ -13,15 +13,9 @@
 const geminiEvalTimeout = 45 * time.Second
 
 func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
-	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
-		raw := form.Value["eval_output"][0]
-		out, err := parseEvalOutput(raw)
-		if err != nil {
-			return EvalOutput{}, err
-		}
-		if err := validateEvalOutput(out, enabled); err != nil {
-			return EvalOutput{}, err
-		}
+	if out, provided, err := parseEvalOutputProvided(form, enabled); err != nil {
+		return EvalOutput{}, err
+	} else if provided {
 		return out, nil
 	}
 	return evalWithGemini(ctx, enabled, runsDir, spec, datasetFile, imageFiles), nil
diff --git a/backend/internal/evaluate/handler.go b/backend/internal/evaluate/handler.go
index 4f4ec64db9c59520ce0dccb60daa693b94c4fbad..597d295ae76228e0d0cabbe860b4e2b0c6031827
--- a/backend/internal/evaluate/handler.go
+++ b/backend/internal/evaluate/handler.go
@@ -221,19 +221,12 @@
 }
 
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
 		return EvalOutput{}, err
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
 	return out, nil
 }
@@ -261,6 +254,27 @@
 	return json.Marshal(v)
 }
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
 	if err == nil {
 		return false
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index 74c11047c23b20e18c977522b72a884927f6ec2c..54f830c7858f496279c6f604af18d16d2a16ac05
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -226,6 +226,32 @@
 	}
 }
 
+func TestParseEvalOutputOptional_IgnoresWhitespace(t *testing.T) {
+	spec := Spec{
+		SchemaVersion: 1,
+		Constraints: []Constraint{
+			{ID: "pii_exposure_risk", Enabled: true, AllowedMaxSeverity: 1},
+			{ID: "harm_enabling_content_risk", Enabled: true, AllowedMaxSeverity: 2},
+		},
+	}
+	enabled, err := enabledConstraints(spec)
+	if err != nil {
+		t.Fatalf("enabledConstraints error: %v", err)
+	}
+
+	form := &multipart.Form{Value: map[string][]string{"eval_output": {" \n\t "}}}
+	out, err := parseEvalOutputOptional(form, enabled)
+	if err != nil {
+		t.Fatalf("parseEvalOutputOptional error: %v", err)
+	}
+	if len(out.Constraints) != len(enabled) {
+		t.Fatalf("expected %d constraints, got %d", len(enabled), len(out.Constraints))
+	}
+	if out.MaxSeverity != 0 {
+		t.Fatalf("expected max_severity 0, got %d", out.MaxSeverity)
+	}
+}
+
 func TestComputePolicyResult(t *testing.T) {
 	enabled := map[string]ConstraintRule{
 		"pii":    {ID: "pii", AllowedMaxSeverity: 1},

codex
What I changed
- Centralized `eval_output` parsing so Gemini and non-Gemini paths consistently reject multiple values and treat whitespace-only input as “not provided,” with a small test covering the whitespace case.

Tests run
- `go test ./...`

Next steps (pick one)
1. Add a small integration test to confirm multipart whitespace `eval_output` triggers Gemini fallback when API key is set.
2. Tighten validation around `eval_output` schema version mismatches with a targeted unit test.
file update:
diff --git a/backend/internal/evaluate/gemini_eval.go b/backend/internal/evaluate/gemini_eval.go
index b440de2eef71bfd21bf7b291ae3a2924998ad61c..f0d96de23750e2fe965b8099573e084b3eba9356
--- a/backend/internal/evaluate/gemini_eval.go
+++ b/backend/internal/evaluate/gemini_eval.go
@@ -13,15 +13,9 @@
 const geminiEvalTimeout = 45 * time.Second
 
 func resolveEvalOutput(ctx context.Context, form *multipart.Form, enabled map[string]ConstraintRule, runsDir string, spec Spec, datasetFile *multipart.FileHeader, imageFiles []*multipart.FileHeader) (EvalOutput, error) {
-	if form != nil && len(form.Value["eval_output"]) > 0 && form.Value["eval_output"][0] != "" {
-		raw := form.Value["eval_output"][0]
-		out, err := parseEvalOutput(raw)
-		if err != nil {
-			return EvalOutput{}, err
-		}
-		if err := validateEvalOutput(out, enabled); err != nil {
-			return EvalOutput{}, err
-		}
+	if out, provided, err := parseEvalOutputProvided(form, enabled); err != nil {
+		return EvalOutput{}, err
+	} else if provided {
 		return out, nil
 	}
 	return evalWithGemini(ctx, enabled, runsDir, spec, datasetFile, imageFiles), nil
diff --git a/backend/internal/evaluate/handler.go b/backend/internal/evaluate/handler.go
index 4f4ec64db9c59520ce0dccb60daa693b94c4fbad..597d295ae76228e0d0cabbe860b4e2b0c6031827
--- a/backend/internal/evaluate/handler.go
+++ b/backend/internal/evaluate/handler.go
@@ -221,19 +221,12 @@
 }
 
 func parseEvalOutputOptional(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, error) {
-	if form == nil || len(form.Value["eval_output"]) == 0 || form.Value["eval_output"][0] == "" {
-		return stubEvalOutput(enabled), nil
-	}
-	if len(form.Value["eval_output"]) > 1 {
-		return EvalOutput{}, fmt.Errorf("only one eval_output value allowed")
-	}
-	raw := form.Value["eval_output"][0]
-	out, err := parseEvalOutput(raw)
+	out, provided, err := parseEvalOutputProvided(form, enabled)
 	if err != nil {
 		return EvalOutput{}, err
 	}
-	if err := validateEvalOutput(out, enabled); err != nil {
-		return EvalOutput{}, err
+	if !provided {
+		return stubEvalOutput(enabled), nil
 	}
 	return out, nil
 }
@@ -261,6 +254,27 @@
 	return json.Marshal(v)
 }
 
+func parseEvalOutputProvided(form *multipart.Form, enabled map[string]ConstraintRule) (EvalOutput, bool, error) {
+	if form == nil || len(form.Value["eval_output"]) == 0 {
+		return EvalOutput{}, false, nil
+	}
+	if len(form.Value["eval_output"]) > 1 {
+		return EvalOutput{}, true, fmt.Errorf("only one eval_output value allowed")
+	}
+	raw := strings.TrimSpace(form.Value["eval_output"][0])
+	if raw == "" {
+		return EvalOutput{}, false, nil
+	}
+	out, err := parseEvalOutput(raw)
+	if err != nil {
+		return EvalOutput{}, true, err
+	}
+	if err := validateEvalOutput(out, enabled); err != nil {
+		return EvalOutput{}, true, err
+	}
+	return out, true, nil
+}
+
 func isBodyTooLarge(err error) bool {
 	if err == nil {
 		return false
diff --git a/backend/internal/evaluate/handler_test.go b/backend/internal/evaluate/handler_test.go
index 74c11047c23b20e18c977522b72a884927f6ec2c..54f830c7858f496279c6f604af18d16d2a16ac05
--- a/backend/internal/evaluate/handler_test.go
+++ b/backend/internal/evaluate/handler_test.go
@@ -226,6 +226,32 @@
 	}
 }
 
+func TestParseEvalOutputOptional_IgnoresWhitespace(t *testing.T) {
+	spec := Spec{
+		SchemaVersion: 1,
+		Constraints: []Constraint{
+			{ID: "pii_exposure_risk", Enabled: true, AllowedMaxSeverity: 1},
+			{ID: "harm_enabling_content_risk", Enabled: true, AllowedMaxSeverity: 2},
+		},
+	}
+	enabled, err := enabledConstraints(spec)
+	if err != nil {
+		t.Fatalf("enabledConstraints error: %v", err)
+	}
+
+	form := &multipart.Form{Value: map[string][]string{"eval_output": {" \n\t "}}}
+	out, err := parseEvalOutputOptional(form, enabled)
+	if err != nil {
+		t.Fatalf("parseEvalOutputOptional error: %v", err)
+	}
+	if len(out.Constraints) != len(enabled) {
+		t.Fatalf("expected %d constraints, got %d", len(enabled), len(out.Constraints))
+	}
+	if out.MaxSeverity != 0 {
+		t.Fatalf("expected max_severity 0, got %d", out.MaxSeverity)
+	}
+}
+
 func TestComputePolicyResult(t *testing.T) {
 	enabled := map[string]ConstraintRule{
 		"pii":    {ID: "pii", AllowedMaxSeverity: 1},

tokens used
16,674
What I changed
- Centralized `eval_output` parsing so Gemini and non-Gemini paths consistently reject multiple values and treat whitespace-only input as “not provided,” with a small test covering the whitespace case.

Tests run
- `go test ./...`

Next steps (pick one)
1. Add a small integration test to confirm multipart whitespace `eval_output` triggers Gemini fallback when API key is set.
2. Tighten validation around `eval_output` schema version mismatches with a targeted unit test.
