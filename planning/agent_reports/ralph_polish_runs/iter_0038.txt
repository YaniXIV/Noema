OpenAI Codex v0.98.0 (research preview)
--------
workdir: /Users/yani/Noema/backend
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: workspace-write [workdir, /tmp, $TMPDIR]
reasoning effort: none
reasoning summaries: auto
session id: 019c3ca0-6dfd-79b3-a1eb-80d39f8a60fe
--------
user
You are an autonomous coding agent polishing the Noema repository.

Hard rules:
- DO NOT run git commit, git reset, git clean, or anything that modifies git history.
- I will run git commits outside of you.
- Keep changes small: max 3 files per iteration.
- No cosmetic-only edits.
- No new dependencies unless absolutely necessary.

Goal: continuously improve production quality.

Iteration:
1) Run: cd backend && go test ./...
2) If failing: fix the smallest root cause (max 3 files), rerun tests until passing.
3) If passing: make ONE meaningful improvement (max 3 files), then rerun tests until passing.

Pick the highest-value improvement:
A) Reliability/correctness: validation, error handling, run persistence, verify robustness
B) Tests: add/strengthen tests for the change you made
C) Gemini integration correctness (only when eval_output missing) with deterministic fallback
D) Maintainability: reduce duplication with tiny refactors
E) UX: wizard/results/verify clarity (small, safe changes)
F) Docs: README/DEPLOYMENT polish
G) Performance: safe wins only

Finish with:
- What you changed (short)
- Tests run (must include go test ./...)
mcp startup: no servers

thinking
**Running tests with exec_command**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend succeeded in 326ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
ok  	noema/internal/evaluate	(cached)
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/httputil	(cached)
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	(cached)
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)

thinking
**Planning targeted improvement**

I'm aiming to enhance one meaningful area with changes in up to three files, so I'll inspect the repo next and search for TODOs to identify a suitable scope.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "TODO|FIXME|XXX"' in /Users/yani/Noema/backend exited 1 in 52ms:


thinking
**Inspecting error handling in handlers**

I'm focusing on internal/web to check if error handling in HTTP handlers is reliable and correct, aiming to identify improvement opportunities.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && ls' in /Users/yani/Noema/backend succeeded in 52ms:
cmd
data
go.mod
go.sum
internal
main
server
web

thinking
**Planning error handling validation**

I'm inspecting internal/session and httputil modules to add error handling validation. I'll search for related error handling patterns next.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && rg -n \"panic|Must|Fatal|log\\.Fatal|TODO|FIXME|unsafe\" internal" in /Users/yani/Noema/backend succeeded in 52ms:
internal/session/session_test.go:16:		t.Fatalf("expected verify ok")
internal/session/session_test.go:19:		t.Fatalf("expected payload %q, got %q", payload, got)
internal/session/session_test.go:29:		t.Fatalf("expected signed value to contain dot")
internal/session/session_test.go:41:		t.Fatalf("expected tampered signature to fail")
internal/session/session_test.go:58:			t.Fatalf("expected verify to fail for %q", tc)
internal/evaluate/handler_test.go:36:			t.Fatalf("create part: %v", err)
internal/evaluate/handler_test.go:39:			t.Fatalf("write part: %v", err)
internal/evaluate/handler_test.go:43:		t.Fatalf("close writer: %v", err)
internal/evaluate/handler_test.go:49:		t.Fatalf("read form: %v", err)
internal/evaluate/handler_test.go:67:		t.Fatalf("enabledConstraints error: %v", err)
internal/evaluate/handler_test.go:73:		t.Fatalf("parseEvalOutputOptional error: %v", err)
internal/evaluate/handler_test.go:76:		t.Fatalf("expected schema_version 1, got %d", out.SchemaVersion)
internal/evaluate/handler_test.go:79:		t.Fatalf("expected max_severity 0, got %d", out.MaxSeverity)
internal/evaluate/handler_test.go:82:		t.Fatalf("expected %d constraints, got %d", len(enabled), len(out.Constraints))
internal/evaluate/handler_test.go:88:			t.Fatalf("expected severity 0 for %s, got %d", c.ID, c.Severity)
internal/evaluate/handler_test.go:91:			t.Fatalf("expected rationale for %s", c.ID)
internal/evaluate/handler_test.go:96:		t.Fatalf("expected constraints sorted by id, got %v", ids)
internal/evaluate/handler_test.go:110:		t.Fatalf("enabledConstraints error: %v", err)
internal/evaluate/handler_test.go:123:		t.Fatalf("marshal eval_output: %v", err)
internal/evaluate/handler_test.go:129:		t.Fatalf("parseEvalOutputOptional error: %v", err)

thinking
**Inspecting handler for robustness**
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/verify/handler.go" in /Users/yani/Noema/backend succeeded in 52ms:
package verify

import (
	"encoding/base64"
	"fmt"
	"net/http"
	"strings"

	"noema/internal/config"
	"noema/internal/httputil"
	"noema/internal/zk"

	"github.com/gin-gonic/gin"
)

// VerifyRequest is the JSON body for POST /api/verify.
type VerifyRequest struct {
	RunID           string `json:"run_id"`
	ProofB64        string `json:"proof_b64"`
	PublicInputsB64 string `json:"public_inputs_b64"`

thinking
**Considering validation robustness**

I'm questioning whether base64 decoding is strict enough or might accept non-canonical inputs, and plan to check other areas like internal/httputil/body.go for related validation.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/httputil/body.go" in /Users/yani/Noema/backend succeeded in 51ms:
package httputil

import (
	"errors"
	"net/http"
	"strings"
)

// IsBodyTooLarge reports whether the error indicates the request body exceeded MaxBytesReader.
func IsBodyTooLarge(err error) bool {
	if err == nil {
		return false
	}
	var maxBytesErr *http.MaxBytesError
	if errors.As(err, &maxBytesErr) {
		return true
	}
	msg := err.Error()
	return strings.Contains(msg, "request body too large") ||
		strings.Contains(msg, "multipart: message too large")

thinking
**Considering stricter run_id validation**

I'm exploring whether to reject or trim whitespace in run_id during legacy verification and will check the verify handler tests to understand how this impacts existing test coverage.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/verify/handler_test.go" in /Users/yani/Noema/backend succeeded in 52ms:
package verify

import (
	"encoding/base64"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"noema/internal/config"

	"github.com/gin-gonic/gin"
)

type errorResponse struct {
	Error string `json:"error"`
}

func setupRouter() *gin.Engine {

thinking
**Considering error handling improvements**

I'm reviewing if error handling for missing Content-Type is necessary since ShouldBindJSON might already handle it; next, I'll inspect the internal evaluation handler for run persistence reliability.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/handler.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"encoding/json"
	"fmt"
	"log"
	"mime/multipart"
	"net/http"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"noema/internal/config"
	"noema/internal/httputil"
	"noema/internal/zk"

	"github.com/gin-gonic/gin"
)
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '200,400p' internal/evaluate/handler.go" in /Users/yani/Noema/backend succeeded in 52ms:
			continue
		}
		runs = append(runs, runEntry{
			path:    filepath.Join(runsDir, entry.Name()),
			modTime: info.ModTime(),
		})
	}

	if len(runs) <= maxRuns {
		return nil
	}

	sort.Slice(runs, func(i, j int) bool {
		return runs[i].modTime.After(runs[j].modTime)
	})

	for i := maxRuns; i < len(runs); i++ {
		if err := os.RemoveAll(runs[i].path); err != nil {
			return err
		}

thinking
**Considering robustness improvements**

I'm evaluating enhancements to pruneRuns, error handling in ensureRunDir, and safer run_id handling including whitespace trimming and path separator checks; next, Iâ€™ll focus on inspecting parseUploads for dataset filename limits.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/evaluate/uploads.go" in /Users/yani/Noema/backend exited 1 in 52ms:
sed: internal/evaluate/uploads.go: No such file or directory

thinking
**Searching for relevant file**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "func parseUploads" -S internal/evaluate' in /Users/yani/Noema/backend succeeded in 52ms:
internal/evaluate/parse.go:56:func parseUploads(form *multipart.Form) (*multipart.FileHeader, []*multipart.FileHeader, error) {
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,220p' internal/evaluate/parse.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"strings"

	"noema/internal/config"
)

func parseSpec(form *multipart.Form) (Spec, error) {
	specStrs := form.Value["spec"]
	if len(specStrs) == 0 || specStrs[0] == "" {
		return Spec{}, fmt.Errorf("missing field: spec")
	}
	if len(specStrs) > 1 {
		return Spec{}, fmt.Errorf("only one spec value allowed")
	}

thinking
**Checking dataset file size validation**

I'm planning to verify if the code or tests handle empty dataset files, focusing on the readDatasetFile function to see if it ensures non-empty input.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "readDatasetFile" -S internal/evaluate' in /Users/yani/Noema/backend succeeded in 51ms:
internal/evaluate/parse.go:89:	_, ds, err := readDatasetFile(fh)
internal/evaluate/dataset.go:23:func readDatasetFile(fh *multipart.FileHeader) ([]byte, Dataset, error) {
internal/evaluate/gemini_eval.go:29:	rawDataset, ds, err := readDatasetFile(datasetFile)
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/dataset.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"mime/multipart"
	"strings"
)

type Dataset struct {
	Items []DatasetItem `json:"items"`
}

type DatasetItem struct {
	ID       string         `json:"id"`
	Text     string         `json:"text"`
	Metadata map[string]any `json:"metadata,omitempty"`
	ImageRef string         `json:"image_ref,omitempty"`

thinking
**Planning dataset item count validation**

Considering adding a validation step to ensure dataset item count doesn't exceed a configurable maximum, since the current decode lacks size checks despite upload limits. I'll check the config for a suitable limit to enforce here.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/config/config.go" in /Users/yani/Noema/backend succeeded in 52ms:
package config

import (
	"os"
	"strconv"

	"github.com/joho/godotenv"
)

const devCookieSecret = "dev-secret-change-in-production"

// Load reads .env from the current directory and sets env vars.
// Safe to call multiple times; existing env vars are not overwritten.
func Load() error {
	return godotenv.Load()
}

// JudgeKey returns the judge key used to gate protected routes.
func JudgeKey() string {
	return os.Getenv("JUDGE_KEY")

thinking
**Reviewing base64 handling and form usage**

Noting base64 decoding uses a standard method that tolerates newlines, so no immediate issue there. Considering trimming whitespace in verification as a minor enhancement. Also confirming form removal calls are safe when form is nil. Next, inspecting computePolicyResult for further insights.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/policy.go" in /Users/yani/Noema/backend succeeded in 51ms:
package evaluate

import "fmt"

type ConstraintRule struct {
	ID                 string
	AllowedMaxSeverity int
}

func enabledConstraints(spec Spec) (map[string]ConstraintRule, error) {
	out := make(map[string]ConstraintRule)
	for _, c := range spec.Constraints {
		if !c.Enabled {
			continue
		}
		if _, exists := out[c.ID]; exists {
			return nil, fmt.Errorf("duplicate constraint id: %s", c.ID)
		}
		out[c.ID] = ConstraintRule{ID: c.ID, AllowedMaxSeverity: c.AllowedMaxSeverity}
	}

thinking
**Noting potential improvements for validation and error handling**

Identified possible enhancements in policy result evaluation, legacy proof verification, update runs indexing reliability, HTTP body size error detection, dataset JSON parsing efficiency, error message specificity, and safeguarding against path traversal in saved filenames.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && rg -n "saveRunFiles" -S internal/evaluate' in /Users/yani/Noema/backend succeeded in 52ms:
internal/evaluate/storage.go:32:func saveRunFiles(runPath string, dataset *multipart.FileHeader, images []*multipart.FileHeader) error {
internal/evaluate/handler.go:93:		if err := saveRunFiles(runPath, datasetFile, imageFiles); err != nil {
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/evaluate/storage.go" in /Users/yani/Noema/backend succeeded in 52ms:
package evaluate

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"mime/multipart"
	"os"
	"path/filepath"
	"strconv"
	"sync/atomic"
	"time"
)

var runIDCounter uint64

func genRunID() string {
	n, err := rand.Int(rand.Reader, big.NewInt(1e9))

thinking
**Reviewing error handling and validation limits**

Noticing potential robustness improvements around dataset item count limits and error messages in verification, with a plan to check proof verification error handling for empty messages to enhance reliability and avoid silent failures.
exec
/bin/zsh -lc "cd /Users/yani/Noema/backend && sed -n '1,200p' internal/zk/zk.go" in /Users/yani/Noema/backend succeeded in 52ms:
package zk

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"strconv"
	"strings"
)

const (
	ProofSystem = "groth16"
	ProofCurve  = "bn254"

	publicInputsPrefix = "noema_public_inputs_v1|"
	proofPrefix        = "noema_stub_proof_v1|"
)

// PublicInputs define the public inputs for policy aggregation.


thinking
**Noting potential input validation improvements**

Several handlers could improve input validation and error handling, like trimming whitespace from base64 before decoding and better JSON decoding checks to reject malicious or malformed input. Also, verifying file extension extraction in saving files to avoid unsafe names may be worthwhile.
thinking
**Planning trim-and-validate input improvements**

I'm preparing to trim whitespace from run ID, proof, and public inputs in the verify handler to reject empty or whitespace-only fields more reliably, updating calls and tests accordingly while keeping changes small and focused on handler.go and handler_test.go.
file update
M /Users/yani/Noema/backend/internal/verify/handler.go
@@ -43,3 +43,7 @@
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
@@ -47,3 +51,3 @@
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
@@ -52,3 +56,3 @@
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
@@ -59,3 +63,3 @@
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
@@ -66,3 +70,3 @@
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
@@ -72,3 +76,3 @@
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
apply_patch(auto_approved=true) exited 0 in 30ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/verify/handler.go
file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})

file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})


thinking
**Adding test with patch application**
file update
M /Users/yani/Noema/backend/internal/verify/handler_test.go
@@ -129,2 +129,27 @@
 
+func TestVerifyHandlerWhitespaceRunIDReturns400(t *testing.T) {
+	r := setupRouter()
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}` 
+
+	w := httptest.NewRecorder()
+	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("new request: %v", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	r.ServeHTTP(w, req)
+
+	if w.Code != http.StatusBadRequest {
+		t.Fatalf("expected status 400, got %d", w.Code)
+	}
+
+	var resp errorResponse
+	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
+		t.Fatalf("decode response: %v", err)
+	}
+	if resp.Error != "missing run_id" {
+		t.Fatalf("expected missing run_id, got %q", resp.Error)
+	}
+}
+
 func TestVerifyHandlerBodyTooLargeReturns413(t *testing.T) {
@@ -132,3 +157,3 @@
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)
-	body := `{"run_id":"` + largeRunID + `","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
+	body := `{"run_id":"` + largeRunID + `","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}` 
 
apply_patch(auto_approved=true) exited 0 in 36ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/verify/handler_test.go
file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})
diff --git a/backend/internal/verify/handler_test.go b/backend/internal/verify/handler_test.go
index 900f6759e30fc3df51d9676c6f834bf38c187ddd..1be7e0e051cedf41d99eed337e4a5713d4a425f9
--- a/backend/internal/verify/handler_test.go
+++ b/backend/internal/verify/handler_test.go
@@ -127,10 +127,35 @@
 	}
 }
 
+func TestVerifyHandlerWhitespaceRunIDReturns400(t *testing.T) {
+	r := setupRouter()
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}` 
+
+	w := httptest.NewRecorder()
+	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("new request: %v", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	r.ServeHTTP(w, req)
+
+	if w.Code != http.StatusBadRequest {
+		t.Fatalf("expected status 400, got %d", w.Code)
+	}
+
+	var resp errorResponse
+	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
+		t.Fatalf("decode response: %v", err)
+	}
+	if resp.Error != "missing run_id" {
+		t.Fatalf("expected missing run_id, got %q", resp.Error)
+	}
+}
+
 func TestVerifyHandlerBodyTooLargeReturns413(t *testing.T) {
 	r := setupRouter()
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)
-	body := `{"run_id":"` + largeRunID + `","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
+	body := `{"run_id":"` + largeRunID + `","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}` 
 
 	w := httptest.NewRecorder()
 	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))

file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})
diff --git a/backend/internal/verify/handler_test.go b/backend/internal/verify/handler_test.go
index 900f6759e30fc3df51d9676c6f834bf38c187ddd..1be7e0e051cedf41d99eed337e4a5713d4a425f9
--- a/backend/internal/verify/handler_test.go
+++ b/backend/internal/verify/handler_test.go
@@ -127,10 +127,35 @@
 	}
 }
 
+func TestVerifyHandlerWhitespaceRunIDReturns400(t *testing.T) {
+	r := setupRouter()
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}` 
+
+	w := httptest.NewRecorder()
+	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("new request: %v", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	r.ServeHTTP(w, req)
+
+	if w.Code != http.StatusBadRequest {
+		t.Fatalf("expected status 400, got %d", w.Code)
+	}
+
+	var resp errorResponse
+	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
+		t.Fatalf("decode response: %v", err)
+	}
+	if resp.Error != "missing run_id" {
+		t.Fatalf("expected missing run_id, got %q", resp.Error)
+	}
+}
+
 func TestVerifyHandlerBodyTooLargeReturns413(t *testing.T) {
 	r := setupRouter()
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)
-	body := `{"run_id":"` + largeRunID + `","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
+	body := `{"run_id":"` + largeRunID + `","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}` 
 
 	w := httptest.NewRecorder()
 	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))


thinking
**Removing trailing spaces**

Trailing spaces were found before closing quotes in JSON body strings, including new and existing lines. I'll adjust the patch to remove these spaces to avoid formatting issues and keep the code clean.
file update
M /Users/yani/Noema/backend/internal/verify/handler_test.go
@@ -131,3 +131,3 @@
 	r := setupRouter()
-	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}` 
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
 
@@ -157,3 +157,3 @@
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)
-	body := `{"run_id":"` + largeRunID + `","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}` 
+	body := `{"run_id":"` + largeRunID + `","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
 
apply_patch(auto_approved=true) exited 0 in 43ms:
Success. Updated the following files:
M /Users/yani/Noema/backend/internal/verify/handler_test.go
file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})
diff --git a/backend/internal/verify/handler_test.go b/backend/internal/verify/handler_test.go
index 900f6759e30fc3df51d9676c6f834bf38c187ddd..7f90c44e99030347d9b6f494d9fed8d50e6af36e
--- a/backend/internal/verify/handler_test.go
+++ b/backend/internal/verify/handler_test.go
@@ -127,6 +127,31 @@
 	}
 }
 
+func TestVerifyHandlerWhitespaceRunIDReturns400(t *testing.T) {
+	r := setupRouter()
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
+
+	w := httptest.NewRecorder()
+	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("new request: %v", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	r.ServeHTTP(w, req)
+
+	if w.Code != http.StatusBadRequest {
+		t.Fatalf("expected status 400, got %d", w.Code)
+	}
+
+	var resp errorResponse
+	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
+		t.Fatalf("decode response: %v", err)
+	}
+	if resp.Error != "missing run_id" {
+		t.Fatalf("expected missing run_id, got %q", resp.Error)
+	}
+}
+
 func TestVerifyHandlerBodyTooLargeReturns413(t *testing.T) {
 	r := setupRouter()
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)

file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})
diff --git a/backend/internal/verify/handler_test.go b/backend/internal/verify/handler_test.go
index 900f6759e30fc3df51d9676c6f834bf38c187ddd..7f90c44e99030347d9b6f494d9fed8d50e6af36e
--- a/backend/internal/verify/handler_test.go
+++ b/backend/internal/verify/handler_test.go
@@ -127,6 +127,31 @@
 	}
 }
 
+func TestVerifyHandlerWhitespaceRunIDReturns400(t *testing.T) {
+	r := setupRouter()
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
+
+	w := httptest.NewRecorder()
+	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("new request: %v", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	r.ServeHTTP(w, req)
+
+	if w.Code != http.StatusBadRequest {
+		t.Fatalf("expected status 400, got %d", w.Code)
+	}
+
+	var resp errorResponse
+	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
+		t.Fatalf("decode response: %v", err)
+	}
+	if resp.Error != "missing run_id" {
+		t.Fatalf("expected missing run_id, got %q", resp.Error)
+	}
+}
+
 func TestVerifyHandlerBodyTooLargeReturns413(t *testing.T) {
 	r := setupRouter()
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)


thinking
**Planning gofmt on changed Go files**

I'm considering running `gofmt -w` only on modified `.go` files to apply formatting changes efficiently without touching unchanged files.
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && gofmt -w internal/verify/handler.go internal/verify/handler_test.go' in /Users/yani/Noema/backend succeeded in 51ms:

file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})
diff --git a/backend/internal/verify/handler_test.go b/backend/internal/verify/handler_test.go
index 900f6759e30fc3df51d9676c6f834bf38c187ddd..7f90c44e99030347d9b6f494d9fed8d50e6af36e
--- a/backend/internal/verify/handler_test.go
+++ b/backend/internal/verify/handler_test.go
@@ -127,6 +127,31 @@
 	}
 }
 
+func TestVerifyHandlerWhitespaceRunIDReturns400(t *testing.T) {
+	r := setupRouter()
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
+
+	w := httptest.NewRecorder()
+	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("new request: %v", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	r.ServeHTTP(w, req)
+
+	if w.Code != http.StatusBadRequest {
+		t.Fatalf("expected status 400, got %d", w.Code)
+	}
+
+	var resp errorResponse
+	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
+		t.Fatalf("decode response: %v", err)
+	}
+	if resp.Error != "missing run_id" {
+		t.Fatalf("expected missing run_id, got %q", resp.Error)
+	}
+}
+
 func TestVerifyHandlerBodyTooLargeReturns413(t *testing.T) {
 	r := setupRouter()
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)


thinking
**Running all tests**
exec
/bin/zsh -lc 'cd /Users/yani/Noema/backend && go test ./...' in /Users/yani/Noema/backend succeeded in 386ms:
?   	noema/cmd/server	[no test files]
?   	noema/internal/auth	[no test files]
?   	noema/internal/config	[no test files]
?   	noema/internal/crypto	[no test files]
ok  	noema/internal/evaluate	(cached)
?   	noema/internal/gemini	[no test files]
ok  	noema/internal/httputil	(cached)
ok  	noema/internal/session	(cached)
ok  	noema/internal/verify	0.019s
?   	noema/internal/web	[no test files]
ok  	noema/internal/zk	(cached)
file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})
diff --git a/backend/internal/verify/handler_test.go b/backend/internal/verify/handler_test.go
index 900f6759e30fc3df51d9676c6f834bf38c187ddd..7f90c44e99030347d9b6f494d9fed8d50e6af36e
--- a/backend/internal/verify/handler_test.go
+++ b/backend/internal/verify/handler_test.go
@@ -127,6 +127,31 @@
 	}
 }
 
+func TestVerifyHandlerWhitespaceRunIDReturns400(t *testing.T) {
+	r := setupRouter()
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
+
+	w := httptest.NewRecorder()
+	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("new request: %v", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	r.ServeHTTP(w, req)
+
+	if w.Code != http.StatusBadRequest {
+		t.Fatalf("expected status 400, got %d", w.Code)
+	}
+
+	var resp errorResponse
+	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
+		t.Fatalf("decode response: %v", err)
+	}
+	if resp.Error != "missing run_id" {
+		t.Fatalf("expected missing run_id, got %q", resp.Error)
+	}
+}
+
 func TestVerifyHandlerBodyTooLargeReturns413(t *testing.T) {
 	r := setupRouter()
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)


thinking
**Summarizing changes and tests**

I'll provide a minimal summary highlighting what was changed and what tests were run, noting any trimmed run_id or proof inputs. I'll avoid nested bullets and keep the summary concise without suggesting further steps unless essential.
codex
**What You Changed**
- Added trimming/validation for `run_id`, `proof_b64`, and `public_inputs_b64` in `internal/verify/handler.go` so whitespace-only values are rejected consistently.
- Added a test to ensure whitespace `run_id` returns `400` in `internal/verify/handler_test.go`.

**Tests Run**
- `go test ./...`
file update:
diff --git a/backend/internal/verify/handler.go b/backend/internal/verify/handler.go
index 39c184b62287ffc29d9b263102c755a981aa6306..e67d0e83d49f2b37d7b9273d8213b4ff1976e156
--- a/backend/internal/verify/handler.go
+++ b/backend/internal/verify/handler.go
@@ -41,36 +41,40 @@
 			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid JSON body"})
 			return
 		}
-		if req.RunID == "" {
+		runID := strings.TrimSpace(req.RunID)
+		proofB64 := strings.TrimSpace(req.ProofB64)
+		publicInputsB64 := strings.TrimSpace(req.PublicInputsB64)
+
+		if runID == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing run_id"})
 			return
 		}
-		if req.ProofB64 == "" || req.PublicInputsB64 == "" {
+		if proofB64 == "" || publicInputsB64 == "" {
 			c.JSON(http.StatusBadRequest, gin.H{"error": "missing proof or public inputs"})
 			return
 		}
 
-		verified, msg, err := zk.VerifyProof(req.ProofB64, req.PublicInputsB64)
+		verified, msg, err := zk.VerifyProof(proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		if verified || !shouldTryLegacy(msg) {
 			c.JSON(http.StatusOK, VerifyResponse{
-				RunID:    req.RunID,
+				RunID:    runID,
 				Verified: verified,
 				Message:  msg,
 			})
 			return
 		}
 
-		verified, msg, err = verifyLegacyStub(req.RunID, req.ProofB64, req.PublicInputsB64)
+		verified, msg, err = verifyLegacyStub(runID, proofB64, publicInputsB64)
 		if err != nil {
 			c.JSON(http.StatusBadRequest, gin.H{"error": msg})
 			return
 		}
 		c.JSON(http.StatusOK, VerifyResponse{
-			RunID:    req.RunID,
+			RunID:    runID,
 			Verified: verified,
 			Message:  msg,
 		})
diff --git a/backend/internal/verify/handler_test.go b/backend/internal/verify/handler_test.go
index 900f6759e30fc3df51d9676c6f834bf38c187ddd..7f90c44e99030347d9b6f494d9fed8d50e6af36e
--- a/backend/internal/verify/handler_test.go
+++ b/backend/internal/verify/handler_test.go
@@ -127,6 +127,31 @@
 	}
 }
 
+func TestVerifyHandlerWhitespaceRunIDReturns400(t *testing.T) {
+	r := setupRouter()
+	body := `{"run_id":"   ","proof_b64":"` + base64.StdEncoding.EncodeToString([]byte("proof")) + `","public_inputs_b64":"` + base64.StdEncoding.EncodeToString([]byte("inputs")) + `"}`
+
+	w := httptest.NewRecorder()
+	req, err := http.NewRequest(http.MethodPost, "/api/verify", strings.NewReader(body))
+	if err != nil {
+		t.Fatalf("new request: %v", err)
+	}
+	req.Header.Set("Content-Type", "application/json")
+	r.ServeHTTP(w, req)
+
+	if w.Code != http.StatusBadRequest {
+		t.Fatalf("expected status 400, got %d", w.Code)
+	}
+
+	var resp errorResponse
+	if err := json.NewDecoder(w.Body).Decode(&resp); err != nil {
+		t.Fatalf("decode response: %v", err)
+	}
+	if resp.Error != "missing run_id" {
+		t.Fatalf("expected missing run_id, got %q", resp.Error)
+	}
+}
+
 func TestVerifyHandlerBodyTooLargeReturns413(t *testing.T) {
 	r := setupRouter()
 	largeRunID := strings.Repeat("a", config.MaxVerifyBytes)

tokens used
38,620
**What You Changed**
- Added trimming/validation for `run_id`, `proof_b64`, and `public_inputs_b64` in `internal/verify/handler.go` so whitespace-only values are rejected consistently.
- Added a test to ensure whitespace `run_id` returns `400` in `internal/verify/handler_test.go`.

**Tests Run**
- `go test ./...`
